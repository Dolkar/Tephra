<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>User Guide | Tephra Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark-tephra.css" />
  <link rel="stylesheet" href="m-documentation.css" />
  <link rel="stylesheet" href="m-theme-dark-tephra.css" />
  <link rel="stylesheet" href="m-grid.css" />
  <link rel="stylesheet" href="m-components.css" />
  <link rel="stylesheet" href="m-layout.css" />
  <link rel="stylesheet" href="pygments-dark.css" />
  <link rel="stylesheet" href="pygments-console.css" />
  <link rel="icon" href="favicon-dark.png" type="image/png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#2c1b15" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <span id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">
        <a href="https://github.com/Dolkar/Tephra">Tephra</a> <span class="m-breadcrumb">|</span> <a href="index.html" class="m-thin">Documentation</a>
      </span>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="user-guide.html" id="m-navbar-current">User Guide</a></li>
            <li><a href="examples.html">Examples and Tests</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="changelog.html">Changelog</a></li>
            <li><a href="https://github.com/Dolkar/Tephra/discussions">Discussions</a></li>
            <li><a href="annotated.html">API</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          User Guide
        </h1>
        <p>A high-level overview of the concepts and functionality in Tephra.</p>
        <nav class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li>
              <a href="#ug-introduction">Introduction</a>
              <ul>
                <li><a href="#ug-introduction-setup-and-build">Setup and build</a></li>
                <li><a href="#ug-introduction-folder-structure">Folder structure</a></li>
                <li><a href="#ug-introduction-additional-resources">Additional resources</a></li>
              </ul>
            </li>
            <li>
              <a href="#ug-general-concepts">General concepts</a>
              <ul>
                <li><a href="#ug-general-concepts-interface-tools">Interface tools</a></li>
                <li><a href="#ug-general-concepts-debugging-and-validation">Debugging and validation</a></li>
                <li><a href="#ug-general-concepts-object-lifetime-and-hierarchy">Object lifetime and hierarchy</a></li>
                <li><a href="#ug-general-concepts-thread-safety">Thread safety</a></li>
                <li><a href="#ug-general-concepts-vulkan-interoperation">Vulkan interoperation</a></li>
              </ul>
            </li>
            <li>
              <a href="#ug-initialization">Initialization</a>
              <ul>
                <li><a href="#ug-initialization-application">Application</a></li>
                <li><a href="#ug-initialization-choosing-a-device">Choosing a device</a></li>
                <li><a href="#ug-initialization-creating-a-device">Creating a device</a></li>
              </ul>
            </li>
            <li>
              <a href="#ug-resources">Resources</a>
              <ul>
                <li><a href="#ug-resources-buffers">Buffers</a></li>
                <li><a href="#ug-resources-images">Images</a></li>
              </ul>
            </li>
            <li>
              <a href="#ug-submits">Submitting work</a>
              <ul>
                <li><a href="#ug-submits-jobs">Jobs</a></li>
                <li><a href="#ug-submits-job-command-recording">Job command recording</a></li>
                <li><a href="#ug-submits-compute-passes">Compute Passes</a></li>
                <li><a href="#ug-submits-render-passes">Render Passes</a></li>
                <li><a href="#ug-submits-job-local-resources">Job-local resources</a></li>
                <li><a href="#ug-submits-synchronization">Synchronization</a></li>
              </ul>
            </li>
            <li>
              <a href="#ug-descriptors">Resource descriptors</a>
              <ul>
                <li><a href="#ug-descriptors-layouts">Descriptor set layouts</a></li>
                <li><a href="#ug-descriptors-sets">Descriptor sets</a></li>
                <li><a href="#ug-descriptors-binding">Binding descriptor sets</a></li>
              </ul>
            </li>
            <li>
              <a href="#ug-pipelines">Pipelines</a>
              <ul>
                <li><a href="#ug-pipelines-shaders">Shaders</a></li>
                <li><a href="#ug-pipelines-compute">Compute pipelines</a></li>
                <li><a href="#ug-pipelines-graphics">Graphics pipelines</a></li>
              </ul>
            </li>
            <li><a href="#ug-swapchain">Swapchain</a></li>
            <li>
              <a href="#ug-utilities">Utilities</a>
              <ul>
                <li><a href="#ug-utilities-standard-report-handler">Standard report handler</a></li>
                <li><a href="#ug-utilities-growable-ring-buffer">Growable ring buffer</a></li>
                <li><a href="#ug-utilities-mutable-descriptor-set">Mutable descriptor set</a></li>
              </ul>
            </li>
          </ul>
        </nav>
<p>This user guide aims to introduce the concepts in Tephra in a succinct and practical way. After reading it, you should be knowledgeable about how the API should be used and how to design effective, high-performance engines and applications around it. Most concepts will have example code to help illustrate common usage, with symbols linking to their respective documentation.</p><div class="m-note m-dim"><p>Paragraphs marked like this will offer insights into the relevant implementation details of the library and justifications for its design. It is not needed to read these when first learning the API, but being aware of the inner workings of any tool is necessary to master it.</p></div><p><strong>Prior knowledge of computer graphics is assumed</strong>, but experience with low-level graphics APIs, such as Vulkan and Dx12, should not be required to understand this documentation.</p><p>However, <strong>this guide is still incomplete</strong> and may not touch on all the subjects sufficiently enough. Please reach out or submit an issue if you have a suggestion for how it should be improved.</p><p><br /></p><hr/><section id="ug-introduction"><h2><a href="#ug-introduction">Introduction</a></h2><p>Tephra is a C++ library that provides a higher level abstraction layer around the Vulkan graphics API. It aims to bring some of the convenience, safety and low barrier of entry from older APIs without sacrificing much of the performance and control that Vulkan brings, all under a modern C++17 design. It is <strong>not</strong> a renderer, but a graphics interface akin to OpenGL or Dx11.</p><p><a href="https://www.vulkan.org/">Vulkan</a> is a low-level graphics and compute API developed by Khronos. Their aim was to bring an API that doesn&#x27;t rely on complex drivers translating high-level functionality into the actual commands that need to be sent to the device. Such translation, for example in the OpenGL and Dx11 APIs, required the driver to track the used resources, make guesses about the future to insert synchronization and compile pipelines on the fly. An interface that allows the user to directly push those commands in a cross-platform and cross-vendor way is a major boon for bringing better performance and control. However, much of the same functionality that the driver used to do now needs to be implemented by the user. A <a href="https://github.com/SaschaWillems/Vulkan/blob/master/examples/triangle/triangle.cpp">simple demo</a> that renders a single triangle on the screen takes more than a thousand lines of code and is hard to extend and maintain.</p><p>There is an unreachable goal of having the same convenience of the old APIs, but with the advantages of the new. Tephra tries to get as close to that goal as possible. It implements automatic synchronization and resource tracking much like the drivers used to do, but only for the high-level commands where it is needed the most. Low-level commands, like binds, draws and dispatches enjoy very low overhead and the possibility of multi-threaded recording. Tephra asks for more information from the user and earlier, compared to OpenGL, but it is still a lot less verbose than Vulkan. A similar demo could be written in Tephra in around 100 lines.</p><p>Besides this user guide, Tephra also has an extensive API documentation in Doxygen, which can be browsed <a href="annotated.html">here</a>. Every symbol mentioned in this user guide also links to its documentation here. The generated documentation is also <strong>fully searchable</strong> - notice the search icon in the top right corner of this page.</p><p><br /></p><section id="ug-introduction-setup-and-build"><h3><a href="#ug-introduction-setup-and-build">Setup and build</a></h3><p>Tephra is designed to be used as a statically loaded library. Differences in build configuration or minor/major library version between its interface and the source may break binary compatibility. It is recommended to always build the library within your solution. Tephra also accepts several preprocessor defines to toggle debug information, see ug-general-concepts-debugging-and-validation. These are only used in the library&#x27;s source files and do not affect binary compatibility.</p><p><a href="https://www.lunarg.com/vulkan-sdk/">Vulkan SDK</a> must be installed to build Tephra. The Visual Studio project uses the <code>VULKAN_SDK</code> environment variable to find the Vulkan include files. The minimum supported version of the Vulkan interface can be queried with <a href="structtp_1_1_version.html#a92905c9ddb6550d533a8c81848429546" class="m-doc">tp::<wbr />Version::<wbr />getMaxUsedVulkanAPIVersion</a>. The minimum supported version of Vulkan that the target device needs to support is then <a href="structtp_1_1_version.html#a810581d8618efa853bc3959109e7bffa" class="m-doc">tp::<wbr />Version::<wbr />getMinSupportedVulkanDeviceVersion</a>.</p><p>Only Visual Studio is officially supported as the build environment, but the library does not use any Windows specific features and it shouldn&#x27;t be difficult to get it running on other platforms.</p><p><br /></p></section><section id="ug-introduction-folder-structure"><h3><a href="#ug-introduction-folder-structure">Folder structure</a></h3><ul><li><code>/build</code> - Project files used for building the library, tests, examples and documentation.</li><li><code>/documentation/dox</code> - Documentation source files.</li><li><code>/documentation/html</code> - HTML output of this documentation.</li><li><code>/examples</code> - <a href="examples.html#e-examples" class="m-doc">Example projects and demos</a> showcasing the use of the library.</li><li><code>/include</code> - Include file directory of Tephra and the third party libraries used.<ul><li><code>/include/tephra</code> - The core Tephra interface.<ul><li><code>/include/tephra/tools</code> - Generic classes used to simplify the interface.</li><li><code>/include/tephra/utils</code> - Optional Tephra utilities that build upon the base interface.</li></ul></li><li><code>/include/vma/</code> - <a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">Vulkan Memory Allocator</a> include directory.</li><li><code>/include/interface_glue.hpp</code> - A user editable file for easier integration of the library.</li></ul></li><li><code>/src</code> - The source code files for Tephra and its third party libraries.</li><li><code>/tests</code> - <a href="examples.html#e-examples" class="m-doc">Testing suite</a> for the library.</li></ul><p><br /></p></section><section id="ug-introduction-additional-resources"><h3><a href="#ug-introduction-additional-resources">Additional resources</a></h3><p>While familiarity of the Vulkan API should not be required, a broad understanding of how it works may help give some context to the rest of this user guide. Its ecosystem is very wide and a large part of it is applicable to the users of Tephra as well. Here is a brief list of relevant resources and material for further reading:</p><ul><li><a href="https://renderdoc.org/vulkan-in-30-minutes.html">Vulkan in 30 minutes</a> - A nice introduction to the concepts in the API.</li><li><a href="https://vkguide.dev/">VulkanGuide</a> - One of the better tutorials that will guide you through the use of the Vulkan API in more detail.</li><li><a href="https://registry.khronos.org/vulkan/specs/1.3/html/vkspec.html">Vulkan specification</a> - The main reference for the functionality of the Vulkan API.</li><li><a href="https://vulkan.gpuinfo.org/">Vulkan hardware database</a> - User reported list of the capabilities of every Vulkan compatible device. Very useful for figuring out which features, extensions and formats are commonly supported.</li><li><a href="https://github.com/vinjn/awesome-vulkan">The &quot;Awesome Vulkan&quot; repo</a> - A comprehensive list of anything else you might ever need about Vulkan.</li></ul><p><br /></p><hr/></section></section><section id="ug-general-concepts"><h2><a href="#ug-general-concepts">General concepts</a></h2><p>This section introduces concepts and design choices that apply to the library as a whole. While they are important to understand and deserve an early mention, for a quick start, feel free to skip to the <a href="user-guide.html#ug-initialization" class="m-doc">Initialization</a> section and return back to this one later.</p><section id="ug-general-concepts-interface-tools"><h3><a href="#ug-general-concepts-interface-tools">Interface tools</a></h3><p>Tephra provides several tools to assist with forming its interface and allowing easier integration into existing codebases. The <code>/include/interface_glue.hpp</code> file provides means for customizing this interface.</p><p>Many objects have a lifetime which must be managed by the user through ownership semantics. By default, <a href="namespacetp.html#ae6eb5f06ba3b55ca0acded49e2f6b754" class="m-doc">tp::<wbr />OwningPtr</a> is defined to be <code>std::unique_ptr</code> in the <code><a href="interface__glue_8hpp_source.html" class="m-doc">interface_<wbr />glue.hpp</a></code> file, but if needed, it can be changed to <code>std::shared_ptr</code> or any custom owning pointer implementation. All ownable objects inherit from <a href="classtp_1_1_ownable.html" class="m-doc">tp::<wbr />Ownable</a>, which is also customizable.</p><p>All arrays in the interface are represented by <a href="classtp_1_1_array_view.html" class="m-doc">tp::<wbr />ArrayView</a> and <a href="classtp_1_1_array_parameter.html" class="m-doc">tp::<wbr />ArrayParameter</a>. They are both non-owning views of a variable number of consecutive elements. Because it is non-owning, <a href="classtp_1_1_array_view.html" class="m-doc">tp::<wbr />ArrayView</a> may not refer to temporary arrays, meaning <code class="m-code"><span class="n">tp</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span><span class="w"></span></code> won&#x27;t compile. <a href="classtp_1_1_array_parameter.html" class="m-doc">tp::<wbr />ArrayParameter</a> does not have this limitation, but it is intended to only be used for function parameters that will get consumed immediately, as it may be viewing a temporary array. Thanks to this, you can still write <code class="m-code"><span class="n">tp</span><span class="o">::</span><span class="n">someFunction</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">});</span><span class="w"></span></code></p><p>These array views may also be constructed from existing arrays and objects with the <a href="namespacetp.html#ac25c30fd113465e9cb1a1d9a6cfcbe4d" class="m-doc">tp::<wbr />view</a>, <a href="namespacetp.html#a168b9d57866c11105d3d1a78a104fc22" class="m-doc">tp::<wbr />viewRange</a> and <a href="namespacetp.html#acd4aaf6caffa7325f71fbaca0dfabcef" class="m-doc">tp::<wbr />viewOne</a> functions. <code><a href="interface__glue_8hpp_source.html" class="m-doc">interface_<wbr />glue.hpp</a></code> may be a good place to provide additional overloads to those functions for custom collections of contiguous elements. See <code>/include/tephra/tools/array.hpp</code> for existing overloads for C style arrays, <code>std::vector</code> and <code>std::array</code>.</p><p>Another useful tool is the <a href="classtp_1_1_enum_bit_mask.html" class="m-doc">tp::<wbr />EnumBitMask</a> that simplifies operations on bit masks and clarifies when a single bit or a mask is expected with strong typing. All bit enums in Tephra also have their mask variant type.</p><p><br /></p></section><section id="ug-general-concepts-debugging-and-validation"><h3><a href="#ug-general-concepts-debugging-and-validation">Debugging and validation</a></h3><p>Drivers implementing the Vulkan API aren&#x27;t required to check that it is being used correctly by the user. Incorrect behavior is more often than not unspecified and can lead to anything from driver crashes to working perfectly fine on your machine, the latter being more insidious. As such, validation layers are shipped as part of the Vulkan SDK, which can be then enabled during development. They are then able to validate correct usage without impacting performance when they are not needed.</p><p>Tephra validation works similarly. The library by default doesn&#x27;t check for correct usage, only when built with the <a href="tephra_8hpp.html#a77f85b1ab9615a261c67866df2aaf8a8" class="m-doc">TEPHRA_<wbr />ENABLE_<wbr />DEBUG</a> preprocessor define. Doing so has a performance impact and so is only recommended for debug builds. Vulkan validation can be toggled without needing to rebuild through <a href="structtp_1_1_vulkan_validation_setup.html" class="m-doc">tp::<wbr />VulkanValidationSetup</a> or simply by using the Vulkan Configurator that comes with the SDK.</p><p>Tephra validation is far from complete. User errors or bugs in the library may silently manifest as incorrect usage of the Vulkan API, so it is recommended to also enable Vulkan validation during development. To allow Tephra to consume the resulting validation messages and direct them to the debug report handler, the <a href="namespacetp_1_1_application_extension.html#a87720f5be2958c77e3766715f1e5c38e" class="m-doc">tp::<wbr />ApplicationExtension::<wbr />EXT_DebugUtils</a> extension must also be enabled.</p><p>The library also needs to be given a way to report validation and other kinds of messages. The <a href="classtp_1_1_debug_report_handler.html" class="m-doc">tp::<wbr />DebugReportHandler</a> base class exists for that purpose. A user-provided implementation can translate incoming <a href="structtp_1_1_debug_message.html" class="m-doc">tp::<wbr />DebugMessage</a> messages and report or log them in whatever way it sees fit. Exceptions that are about to be thrown can also be logged. For the sake of convenience, a utility class is provided that implements <a href="classtp_1_1_debug_report_handler.html" class="m-doc">tp::<wbr />DebugReportHandler</a> with a predefined message formatting style: <a href="classtp_1_1utils_1_1_standard_report_handler.html" class="m-doc">tp::<wbr />utils::<wbr />StandardReportHandler</a>. See <a href="user-guide.html#ug-utilities-standard-report-handler" class="m-doc">Standard report handler</a> for more details or the example in <a href="user-guide.html#ug-initialization-application" class="m-doc">Application initialization</a> for a common setup.</p><p>Most Tephra functions that create an object also accept a debug name parameter. The name can be later used to better identify the objects in validation messages. If the <a href="namespacetp_1_1_application_extension.html#a87720f5be2958c77e3766715f1e5c38e" class="m-doc">tp::<wbr />ApplicationExtension::<wbr />EXT_DebugUtils</a> extension is enabled, it will also be exposed to Vulkan validation and debugging utilities, like RenderDoc. Since Tephra objects don&#x27;t always correspond one-to-one with Vulkan objects, it takes extra care to ensure all names propagate properly. Defining <a href="tephra_8hpp.html#ad1ce3bc36c3083aadf569352455e109f" class="m-doc">TEPHRA_<wbr />ENABLE_<wbr />DEBUG_<wbr />NAMES</a> allows Tephra to store debug names and pass them onto internal Vulkan objects. By default, Tephra also suballocates resources, which can make identifying them with Vulkan utilities difficult. This can be turned off for debugging purposes by using the <a href="namespacetp.html#a050e911cb1725a2d06fe0d4ed5072351a8475058aa9d7bb72629e4c5ece818eed" class="m-doc">tp::<wbr />JobResourcePoolFlag::<wbr />DisableSuballocation</a> flag during job resource pool creation.</p><p>It is recommended to name your objects and label command ranges extensively. It will be invaluable when debugging your application.</p><p><br /></p></section><section id="ug-general-concepts-object-lifetime-and-hierarchy"><h3><a href="#ug-general-concepts-object-lifetime-and-hierarchy">Object lifetime and hierarchy</a></h3><p>There are two kinds of types in the base library: The first are pure data structures like <a href="structtp_1_1_application_setup.html" class="m-doc">tp::<wbr />ApplicationSetup</a> that can be created through their constructor and destroyed at any time. The other, more interesting types, are objects like <a href="classtp_1_1_application.html" class="m-doc">tp::<wbr />Application</a>, <a href="classtp_1_1_device.html" class="m-doc">tp::<wbr />Device</a>, <a href="classtp_1_1_image.html" class="m-doc">tp::<wbr />Image</a>, etc. These form a parent-child hierarchy. They can only be created through their parent type&#x27;s methods, like <a href="classtp_1_1_application.html#a415c0b6fcd2e3500caa020f2d96e90d9" class="m-doc">tp::<wbr />Application::<wbr />createDevice</a> or <a href="classtp_1_1_device.html#a7e9b856dc12cb80a9e140f6c8f3a0aab" class="m-doc">tp::<wbr />Device::<wbr />allocateImage</a> and they cannot be used after their parent has been destroyed. The special case is <a href="classtp_1_1_application.html" class="m-doc">tp::<wbr />Application</a>, which has no parent, but is instead created through the <a href="classtp_1_1_application.html#ac7180381e1b42ac52f44747953d918ab" class="m-doc">tp::<wbr />Application::<wbr />createApplication</a> static method.</p><p>Below is the parent-child hierarchy of Tephra&#x27;s objects. Some of these objects follow special rules, as indicated by the symbols next to their names in [] and explained below.</p><ul><li><a href="classtp_1_1_application.html" class="m-doc">tp::<wbr />Application</a> [FL]<ul><li><a href="classtp_1_1_device.html" class="m-doc">tp::<wbr />Device</a> [FL]<ul><li><a href="classtp_1_1_buffer.html" class="m-doc">tp::<wbr />Buffer</a> [E]<ul><li><a href="classtp_1_1_buffer_view.html" class="m-doc">tp::<wbr />BufferView</a></li></ul></li><li><a href="classtp_1_1_descriptor_set_layout.html" class="m-doc">tp::<wbr />DescriptorSetLayout</a> [E]</li><li><a href="classtp_1_1_descriptor_pool.html" class="m-doc">tp::<wbr />DescriptorPool</a><ul><li><a href="classtp_1_1_descriptor_set.html" class="m-doc">tp::<wbr />DescriptorSet</a><ul><li><a href="classtp_1_1_descriptor_set_view.html" class="m-doc">tp::<wbr />DescriptorSetView</a></li></ul></li></ul></li><li><a href="classtp_1_1_image.html" class="m-doc">tp::<wbr />Image</a> [E]<ul><li><a href="classtp_1_1_image_view.html" class="m-doc">tp::<wbr />ImageView</a></li></ul></li><li><a href="classtp_1_1_job_resource_pool.html" class="m-doc">tp::<wbr />JobResourcePool</a><ul><li><a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a> [L]<ul><li><a href="classtp_1_1_buffer_view.html" class="m-doc">tp::<wbr />BufferView</a></li><li><a href="classtp_1_1_image_view.html" class="m-doc">tp::<wbr />ImageView</a></li><li><a href="classtp_1_1_descriptor_set_view.html" class="m-doc">tp::<wbr />DescriptorSetView</a></li><li><a href="classtp_1_1_command_pool.html" class="m-doc">tp::<wbr />CommandPool</a> [N]</li><li><a href="classtp_1_1_compute_list.html" class="m-doc">tp::<wbr />ComputeList</a></li><li><a href="classtp_1_1_render_list.html" class="m-doc">tp::<wbr />RenderList</a></li></ul></li></ul></li><li><a href="classtp_1_1_pipeline.html" class="m-doc">tp::<wbr />Pipeline</a></li><li><a href="classtp_1_1_pipeline_cache.html" class="m-doc">tp::<wbr />PipelineCache</a></li><li><a href="classtp_1_1_pipeline_layout.html" class="m-doc">tp::<wbr />PipelineLayout</a></li><li><a href="classtp_1_1_sampler.html" class="m-doc">tp::<wbr />Sampler</a></li><li><a href="classtp_1_1_shader_module.html" class="m-doc">tp::<wbr />ShaderModule</a></li><li><a href="classtp_1_1_swapchain.html" class="m-doc">tp::<wbr />Swapchain</a> [E]<ul><li><a href="classtp_1_1_image_view.html" class="m-doc">tp::<wbr />ImageView</a></li></ul></li></ul></li><li><a href="classtp_1_1_physical_device.html" class="m-doc">tp::<wbr />PhysicalDevice</a> [N]</li></ul></li></ul><p>Symbol legend:</p><ul><li>[F]: All children created from this object must be destroyed by the time the object itself is destroyed.</li><li>[L]: All children created from this object must only be used locally, in the same context as its parent. For example, a <a href="classtp_1_1_buffer.html" class="m-doc">tp::<wbr />Buffer</a> created by a particular device must only be used in jobs of that device. Similarly job-local objects may only be used inside their parent job.</li><li>[E]: The object&#x27;s lifetime must be extended during job recording. When the object is used inside a command recorded to a <a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a>, the object must not be destroyed until the job is either enqueued or destroyed. The use of its children also counts, like when using the <a href="classtp_1_1_image_view.html" class="m-doc">tp::<wbr />ImageView</a> of an <a href="classtp_1_1_image.html" class="m-doc">tp::<wbr />Image</a>, the parent image must stay alive.</li><li>[N]: The object is not owned by the user, its lifetime is always managed by the library.</li></ul><div class="m-note m-dim"><p>Vulkan requires most of its handles to stay alive during the entire time the GPU is using them, which, in a renderer setting, means keeping them around for several frames. Tephra handles this by extending the lifetime of all objects that hold such Vulkan handles. When an object gets destroyed, its handles get stored in a per-device container with information about the jobs that have been enqueued so far. On some device method calls, like <a href="classtp_1_1_device.html#aac2faa875acd46b70fa584acdbab14f8" class="m-doc">tp::<wbr />Device::<wbr />updateSemaphores</a> and <a href="classtp_1_1_device.html#a229a32a200a0848ecec78210ca09ab1d" class="m-doc">tp::<wbr />Device::<wbr />submitPresentImagesKHR</a>, the jobs are checked for completion on the device and the relevant Vulkan handles will finally be destroyed.</p><p>This is done efficiently through the use of globally incrementing job IDs that are used as values for Vulkan&#x27;s timeline semaphores. When a handle is to be destroyed, a value T gets assigned to it, which is the ID of the last enqueued job. To test whether it can be freed at a later time, the value T is compared to the state of every device queue. If the last signalled timeline semaphore value for that queue is greater than T, or if the queue has finished executing every job previously submitted to it, the handle is guaranteed not to be used and can be safely destroyed.</p><p>This method avoids tracking how the handles are actually used, but comes with the downside that the lifetime is extended regardless of whether the object has actually been used in recent jobs or not. For most handles this does not matter, but it may delay the release of potentially large amounts of memory held by buffers and images. An alternative solution for resources may be implemented in the future.</p></div><p><br /></p></section><section id="ug-general-concepts-thread-safety"><h3><a href="#ug-general-concepts-thread-safety">Thread safety</a></h3><p>Whenever possible, Tephra offers thread safety by virtue of immutability. Many objects cannot be changed after they were created and so pose no harm being used from different threads at the same time. The default rule is that any object may be accessed by multiple threads if both of those acceses are read-only, such as through const methods or by being passed as a const reference. Recording a command like <a href="classtp_1_1_job.html#a4aed4f4ac99e3090785561c937170f5b" class="m-doc">tp::<wbr />Job::<wbr />cmdClearImage</a> still counts as a read-only access for the image, since the write operation takes place later on the gpu, not in the thread itself.</p><p>For the sake of convenience, the methods of <a href="classtp_1_1_device.html" class="m-doc">tp::<wbr />Device</a> are designed to be thread-safe as well, but beware that objects passed to the methods as parameters, such as <a href="structtp_1_1_device_queue.html" class="m-doc">tp::<wbr />DeviceQueue</a> or <a href="classtp_1_1_swapchain.html" class="m-doc">tp::<wbr />Swapchain</a>, in general aren&#x27;t safe to be used like that from multiple threads simultaneously. Further, <a href="classtp_1_1_pipeline_cache.html" class="m-doc">tp::<wbr />PipelineCache</a> is also thread-safe by extension of the Vulkan   <a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html" class="m-doc-external">VkPipelineCache</a> being thread-safe, to simplify multithreaded pipeline compilation.</p><p>Generally, pool objects like <a href="classtp_1_1_job_resource_pool.html" class="m-doc">tp::<wbr />JobResourcePool</a>, <a href="classtp_1_1_descriptor_pool.html" class="m-doc">tp::<wbr />DescriptorPool</a> and <a href="classtp_1_1_command_pool.html" class="m-doc">tp::<wbr />CommandPool</a> not only aren&#x27;t thread-safe by themselves, but also objects allocated from them must collectively only be modified by a single thread at a time. The intended way to record commands from multiple threads is to create a separate pool for each thread.</p><p>Examples of <strong>allowed</strong> multithreaded usage:</p><ul><li>Allocating objects from the same <a href="classtp_1_1_device.html" class="m-doc">tp::<wbr />Device</a>.</li><li>Recording commands that operate on the same object to different <a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a> instances, as long as the jobs were created from different <a href="classtp_1_1_job_resource_pool.html" class="m-doc">tp::<wbr />JobResourcePool</a> instances.</li><li>Allocating <a href="classtp_1_1_descriptor_set.html" class="m-doc">tp::<wbr />DescriptorSet</a> objects that refer to the same resource from different <a href="classtp_1_1_descriptor_pool.html" class="m-doc">tp::<wbr />DescriptorPool</a> instances.</li><li>Mapping and writing to disjoint regions of the same <a href="classtp_1_1_buffer.html" class="m-doc">tp::<wbr />Buffer</a>.</li><li>Recording commands to distinct <a href="classtp_1_1_command_list.html" class="m-doc">tp::<wbr />CommandList</a> objects that will execute within the same <a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a>, as long as the lists are being recorded with different <a href="classtp_1_1_command_pool.html" class="m-doc">tp::<wbr />CommandPool</a> instances.</li><li>Compiling pipelines on the same <a href="classtp_1_1_device.html" class="m-doc">tp::<wbr />Device</a> and using the same <a href="classtp_1_1_pipeline_cache.html" class="m-doc">tp::<wbr />PipelineCache</a>.</li><li>Destroying an object created from a pool while that pool is in use by another thread.</li></ul><p>Examples of <strong>incorrect</strong> multithreaded usage:</p><ul><li>Destroying an object while another thread is still using it.</li><li>Recording commands to the same <a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a> or <a href="classtp_1_1_command_list.html" class="m-doc">tp::<wbr />CommandList</a>.</li><li>Recording commands to different <a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a> instances that were created from the same <a href="classtp_1_1_job_resource_pool.html" class="m-doc">tp::<wbr />JobResourcePool</a>.</li><li>Recording commands to different <a href="classtp_1_1_command_list.html" class="m-doc">tp::<wbr />CommandList</a> instances that were created using the same <a href="classtp_1_1_command_pool.html" class="m-doc">tp::<wbr />CommandPool</a>.</li><li>Allocating <a href="classtp_1_1_descriptor_set.html" class="m-doc">tp::<wbr />DescriptorSet</a> objects from the same <a href="classtp_1_1_descriptor_pool.html" class="m-doc">tp::<wbr />DescriptorPool</a>.</li><li>Enqueuing different <a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a> instances to the same <a href="structtp_1_1_device_queue.html" class="m-doc">tp::<wbr />DeviceQueue</a>.</li><li>Enqueuing a <a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a> while recording commands to another one that was created from the same <a href="classtp_1_1_job_resource_pool.html" class="m-doc">tp::<wbr />JobResourcePool</a>.</li></ul><p><br /></p></section><section id="ug-general-concepts-vulkan-interoperation"><h3><a href="#ug-general-concepts-vulkan-interoperation">Vulkan interoperation</a></h3><p>While this area is still in progress, the library intends to provide a high degree of interoperability with base Vulkan, so that bleeding-edge extensions and third party libraries can be used more comfortably. For providing additional extension-specific information to Vulkan, many functions and setup structures accept a <code>void*</code> pointer that will be appended as the <code>pNext</code> pointer to the relevant Vulkan call. Tephra enums that are marked as Vulkan-compatible can also accept Vulkan values for the corresponding enums that are added by extensions. The extensions offered in <a href="namespacetp_1_1_application_extension.html" class="m-doc">tp::<wbr />ApplicationExtension</a> and <a href="namespacetp_1_1_device_extension.html" class="m-doc">tp::<wbr />DeviceExtension</a> namespaces are fully integrated into Tephra and should not need Vulkan interoperation.</p><p>Some Tephra objects can be created from existing Vulkan handles. First, a handle <a href="classtp_1_1_lifeguard.html" class="m-doc">tp::<wbr />Lifeguard</a> must be constructed from them. The lifeguard provides functionality for automatically destroying the handle. If this is desired, the lifeguard should be constructed with <a href="classtp_1_1_device.html#a1100041005d269717f7489e9037d6b1f" class="m-doc">tp::<wbr />Device::<wbr />vkMakeHandleLifeguard</a>. Or instead, the <a href="classtp_1_1_lifeguard.html#a2a3f1ed8111198255e0a353bcb861ccd" class="m-doc">tp::<wbr />Lifeguard::<wbr />NonOwning</a> factory method can be used to create a non-owning lifeguard that will not destroy the handle at the end of its lifetime. The wrapped handle can then either be passed directly to the Tephra object&#x27;s constructors, or by using special device methods such as <a href="classtp_1_1_device.html#ab0c1d0f65c291890e9b51d34d84528da" class="m-doc">tp::<wbr />Device::<wbr />vkCreateExternalBuffer</a> and <a href="classtp_1_1_device.html#a75969925a0cbafbdfdc8c4163cfa0f5e" class="m-doc">tp::<wbr />Device::<wbr />vkCreateExternalImage</a>. Tephra may not know how to destroy some types of Vulkan handles. Even for those, however, it offers a convenient way to handle their safe destruction through user-defined cleanup callbacks passed to <a href="classtp_1_1_device.html#aac252df59320053535d752f681b990e5" class="m-doc">tp::<wbr />Device::<wbr />addCleanupCallback</a>.</p><p>Most objects also expose access to the internal Vulkan handles with methods like <a href="classtp_1_1_device.html#a0c36ebc5af1d5a1e12ed2427481bc843" class="m-doc">tp::<wbr />Device::<wbr />vkGetDeviceHandle</a>. This can be used, for example, to record an extension Vulkan command to a Tephra command list. For convenience, Vulkan device-level procedures can be loaded directly with <a href="classtp_1_1_device.html#a59bf909458f12faa276cc3deeffd8334" class="m-doc">tp::<wbr />Device::<wbr />vkLoadDeviceProcedure</a>.</p><p><br /></p><hr/></section></section><section id="ug-initialization"><h2><a href="#ug-initialization">Initialization</a></h2><section id="ug-initialization-application"><h3><a href="#ug-initialization-application">Application</a></h3><p>The first stepping stone is to create a <a href="classtp_1_1_application.html" class="m-doc">tp::<wbr />Application</a> object, which initializes Tephra and the underlying Vulkan implementation for use in the application&#x27;s context. To do that, we must create a <a href="structtp_1_1_application_setup.html" class="m-doc">tp::<wbr />ApplicationSetup</a> structure that holds the parameters needed to construct it. In this case all of them are optional, but let&#x27;s go through them anyway.</p><p>The first is <a href="structtp_1_1_application_identifier.html" class="m-doc">tp::<wbr />ApplicationIdentifier</a>, which lets you provide the name and version of your application straight to the Vulkan driver. In case your application becomes popular enough, the driver may use this information to identify and optimize for your app. A tall order for now, but I think it&#x27;s cute to define it anyway.</p><p>Two essential debugging parameters follow. <a href="structtp_1_1_vulkan_validation_setup.html" class="m-doc">tp::<wbr />VulkanValidationSetup</a> lets you enable Vulkan validation. It should be enabled when debugging, along with the <a href="tephra_8hpp.html#a77f85b1ab9615a261c67866df2aaf8a8" class="m-doc">TEPHRA_<wbr />ENABLE_<wbr />DEBUG</a> define, which enables Tephra&#x27;s own validation. Both will warn about various mistakes when using the library. See the <a href="user-guide.html#ug-general-concepts-debugging-and-validation" class="m-doc">Debugging and validation</a> section for more details. These messages will be reported to a debug handler that can be provided as the third parameter.</p><p>The debug handler is an interface that will be used by the library when a validation message or an error occurs. For simplicity, there is a standard implementation of it in Tephra&#x27;s utilities that outputs to a C++ stream, filtered by the chosen message severities and types. See <a href="user-guide.html#ug-utilities-standard-report-handler" class="m-doc">Standard report handler</a>. If all validation and messaging is disabled, the debug handler is unused.</p><p>Next, we can define any requested extensions. These can be either one of the predefined <a href="namespacetp_1_1_application_extension.html" class="m-doc">tp::<wbr />ApplicationExtension</a> extensions, or any other Vulkan instance extensions. They add additional optional functionality to what the base API offers. One of the most useful ones being <a href="namespacetp_1_1_application_extension.html#aed1bc7ad1ffce334894bb898667dc3ec" class="m-doc">tp::<wbr />ApplicationExtension::<wbr />KHR_Surface</a>, which will later enable us to present rendered images to the screen. Whenever you see a Tephra function or class name with the KHR, EXT or other suffix, it is likely a part of either a device or instance extension. The next parameter allows you to specify any additional Vulkan layers, used for letting tools hook into your API calls.</p><p>To finally create the application object, call the static method <a href="classtp_1_1_application.html#ac7180381e1b42ac52f44747953d918ab" class="m-doc">tp::<wbr />Application::<wbr />createApplication</a>. On success, it will return an owning pointer to the object. If the method fails, likely because something was not supported, a <a href="classtp_1_1_runtime_error.html" class="m-doc">tp::<wbr />RuntimeError</a> exception will be thrown. It is also possible to check for support ahead of time with the other static methods, like <a href="classtp_1_1_application.html#ae2d290a69e9cae196c02af8dfb0d1968" class="m-doc">tp::<wbr />Application::<wbr />isExtensionAvailable</a>.</p><pre class="m-code"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tephra/tephra.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tephra/utils/standard_report_handler.hpp&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">debugMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Turn off for release</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">debugHandler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">utils</span><span class="o">::</span><span class="n">StandardReportHandler</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">DebugMessageSeverity</span><span class="o">::</span><span class="n">Warning</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">DebugMessageSeverity</span><span class="o">::</span><span class="n">Error</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Request surface extension, so we can output to a window</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">appExtensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">ApplicationExtension</span><span class="o">::</span><span class="n">KHR_Surface</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">appSetup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ApplicationSetup</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">ApplicationIdentifier</span><span class="p">(</span><span class="s">&quot;Tephra user guide&quot;</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">VulkanValidationSetup</span><span class="p">(</span><span class="n">debugMode</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">debugHandler</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">view</span><span class="p">(</span><span class="n">appExtensions</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">tp</span><span class="o">::</span><span class="n">Application</span><span class="o">&gt;</span><span class="w"> </span><span class="n">app</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">app</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">Application</span><span class="o">::</span><span class="n">createApplication</span><span class="p">(</span><span class="n">appSetup</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">RuntimeError</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Not supported</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p><br /></p></section><section id="ug-initialization-choosing-a-device"><h3><a href="#ug-initialization-choosing-a-device">Choosing a device</a></h3><p>The main purpose of the <a href="classtp_1_1_application.html" class="m-doc">tp::<wbr />Application</a> object is to allow you to pick a <a href="classtp_1_1_physical_device.html" class="m-doc">tp::<wbr />PhysicalDevice</a> available on the system and create a <a href="classtp_1_1_device.html" class="m-doc">tp::<wbr />Device</a> for it, through which most functionality of Tephra can be accessed. To iterate over the available supported devices, call <a href="classtp_1_1_application.html#a15499a3f51c72b60dbec182adbe52c80" class="m-doc">tp::<wbr />Application::<wbr />getPhysicalDevices</a>. The devices are ordered in a platform dependent manner, but usually the first device is the one the operating system deems as primary. Generally, picking the first device in the list that meets your criteria is sufficient. Each <a href="classtp_1_1_physical_device.html" class="m-doc">tp::<wbr />PhysicalDevice</a> provides all kinds of information about the associated device. Refer to the documentation to see what is directly provided. Additional information can be queried directly from Vulkan through the <a href="classtp_1_1_physical_device.html#adb42c7230b1e247a698a0d7425460a3a" class="m-doc">tp::<wbr />PhysicalDevice::<wbr />vkQueryProperties</a> and <a href="classtp_1_1_physical_device.html#a4fda56ed3ec8434de6b7cdbcf10e6b04" class="m-doc">tp::<wbr />PhysicalDevice::<wbr />vkQueryFeatures</a> methods.</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">deviceExtensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">DeviceExtension</span><span class="o">::</span><span class="n">KHR_Swapchain</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">PhysicalDevice</span><span class="o">*</span><span class="w"> </span><span class="n">chosenDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">PhysicalDevice</span><span class="o">&amp;</span><span class="w"> </span><span class="n">candidateDevice</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">application</span><span class="o">-&gt;</span><span class="n">getPhysicalDevices</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Choose a discrete GPU that supports swapchains, geometry shaders and 32-bit depth buffers</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">candidateDevice</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">DeviceType</span><span class="o">::</span><span class="n">DiscreteGPU</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">ext</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">deviceExtensions</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">candidateDevice</span><span class="p">.</span><span class="n">isExtensionAvailable</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">candidateDevice</span><span class="p">.</span><span class="n">vkQueryFeatures</span><span class="o">&lt;</span><span class="n">VkPhysicalDeviceFeatures</span><span class="o">&gt;</span><span class="p">().</span><span class="n">geometryShader</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">depthCaps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">candidateDevice</span><span class="p">.</span><span class="n">queryFormatCapabilities</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">Format</span><span class="o">::</span><span class="n">DEPTH32_D32_SFLOAT</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">depthCaps</span><span class="p">.</span><span class="n">usageMask</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">FormatUsage</span><span class="o">::</span><span class="n">DepthStencilAttachment</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">chosenDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">candidateDevice</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">chosenDevice</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// No physical device supported</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p><br /></p></section><section id="ug-initialization-creating-a-device"><h3><a href="#ug-initialization-creating-a-device">Creating a device</a></h3><p>Creating a <a href="classtp_1_1_device.html" class="m-doc">tp::<wbr />Device</a> out of a particular <a href="classtp_1_1_physical_device.html" class="m-doc">tp::<wbr />PhysicalDevice</a> you wish to commit to using is similar to creating a <a href="classtp_1_1_application.html" class="m-doc">tp::<wbr />Application</a> object, it starts by filling out a setup structure.</p><p>The second parameter, after the physical device pointer, is a list of device queues you wish to use with the device. <a href="structtp_1_1_device_queue.html" class="m-doc">tp::<wbr />DeviceQueue</a> identifies a queue to which jobs can be submitted for executing on the device. Each device queue has a type that describes what kind of commands it can support:</p><ul><li><a href="namespacetp.html#a8b32a8b4b40aee5fed67bc3c3d63ead7a6950810f0d2bba97a6f710c7b965b84e" class="m-doc">tp::<wbr />QueueType::<wbr />Transfer</a> for transfer-only operations, like copying data from one resource to another.</li><li><a href="namespacetp.html#a8b32a8b4b40aee5fed67bc3c3d63ead7aa623a8d0366bf079411aa30be45b2d10" class="m-doc">tp::<wbr />QueueType::<wbr />Compute</a> for compute workloads executing compute shaders. It also supports transfer operations.</li><li><a href="namespacetp.html#a8b32a8b4b40aee5fed67bc3c3d63ead7ad334dfcea59127bedfcdbe0a3ee7f494" class="m-doc">tp::<wbr />QueueType::<wbr />Graphics</a> for graphics workloads executing the graphics pipeline. It also supports compute and transfer operations. The graphics queue is the most powerful and a useful default, but may not be supported on some compute-only accelerator cards that do not support rendering.</li></ul><p>A <a href="structtp_1_1_device_queue.html" class="m-doc">tp::<wbr />DeviceQueue</a> is a combination of a queue type and an index of the queue within that type. One reason why you might want to have multiple queues is asynchronous execution. A transfer queue is often able to copy data around while a graphics queue is busy rendering. Running a compute shader on a compute queue simultaneously to rendering is known as &quot;async-compute&quot; and may result in speedups as well. Another good reason is for thread safety. Multiple queues allow several independent parts of your engine to submit work at the same time using the same Tephra device.</p><p>After you have selected the queues, you must select the extensions. These are similar to application extensions, but are drawn from <a href="namespacetp_1_1_device_extension.html" class="m-doc">tp::<wbr />DeviceExtension</a> instead (or other Vulkan device extensions) and affect only the device-level functionality. Support for them can be checked through the physical device, as shown in the previous section. A notable extension, and a counterpart to <a href="namespacetp_1_1_application_extension.html#aed1bc7ad1ffce334894bb898667dc3ec" class="m-doc">tp::<wbr />ApplicationExtension::<wbr />KHR_Surface</a> is <a href="namespacetp_1_1_device_extension.html#adc15a5a63bec60fa63cc6ea59d1ea392" class="m-doc">tp::<wbr />DeviceExtension::<wbr />KHR_Swapchain</a>, which handles presenting images to the surface with a <a href="classtp_1_1_swapchain.html" class="m-doc">tp::<wbr />Swapchain</a> object. See the <a href="user-guide.html#ug-swapchain" class="m-doc">Swapchain</a> section for more details on that.</p><p>Besides extensions, some functionality of the device needs to be enabled by the use of features. There is   <a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html" class="m-doc-external">VkPhysicalDeviceFeatures</a> as well as other feature structs provided by Vulkan that contain a boolean value for each feature that can be enabled. You&#x27;ve already seen in the previous example how the device support for a feature can be queried with <a href="classtp_1_1_physical_device.html#a4fda56ed3ec8434de6b7cdbcf10e6b04" class="m-doc">tp::<wbr />PhysicalDevice::<wbr />vkQueryFeatures</a>, but to actually enable it, its value must be set to <code class="m-code"><span class="nb">true</span><span class="w"></span></code> in a <a href="namespacetp.html#ab6d2edf195b1f62b81c67845e61c243c" class="m-doc">tp::<wbr />VkFeatureMap</a> that gets passed to the device as a parameter. Initially, the map starts with all features turned off. Turning one on is as simple as:</p><pre class="m-code"><span class="n">tp</span><span class="o">::</span><span class="n">VkFeatureMap</span><span class="w"> </span><span class="n">features</span><span class="p">;</span><span class="w"></span>
<span class="n">features</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">VkPhysicalDeviceFeatures</span><span class="o">&gt;</span><span class="p">().</span><span class="n">geometryShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span></pre><p>Next up is an optional configuration of Tephra&#x27;s internal memory allocator, <a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">VMA</a>, which is used to satisfy all memory needs of resources you can request through the library. Because it is more efficient in Vulkan to allocate larger blocks of memory, but it&#x27;s difficult to find the right block size for every application, it is available as a configurable parameter, set to 256 MB by default.</p><p>Finally, we can create the device using the prepared setup structure, but instead of using a static method, a device is created through a <a href="classtp_1_1_application.html" class="m-doc">tp::<wbr />Application</a> object&#x27;s <a href="classtp_1_1_application.html#a415c0b6fcd2e3500caa020f2d96e90d9" class="m-doc">tp::<wbr />Application::<wbr />createDevice</a> method, becoming its child object.</p><pre class="m-code"><span class="c1">// Create one main queue and two transfer queues for this example</span>
<span class="n">tp</span><span class="o">::</span><span class="n">DeviceQueue</span><span class="w"> </span><span class="n">mainQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">DeviceQueue</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">QueueType</span><span class="o">::</span><span class="n">Graphics</span><span class="p">);</span><span class="w"></span>
<span class="n">tp</span><span class="o">::</span><span class="n">DeviceQueue</span><span class="w"> </span><span class="n">copyQueues</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">DeviceQueue</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">QueueType</span><span class="o">::</span><span class="n">Transfer</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">DeviceQueue</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">QueueType</span><span class="o">::</span><span class="n">Transfer</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="n">tp</span><span class="o">::</span><span class="n">DeviceQueue</span><span class="w"> </span><span class="n">allQueues</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">mainQueue</span><span class="p">,</span><span class="w"> </span><span class="n">copyQueues</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">copyQueues</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="c1">// We have already prepared the supported physical device, extensions and features</span>
<span class="k">auto</span><span class="w"> </span><span class="n">deviceSetup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">DeviceSetup</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">chosenDevice</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">view</span><span class="p">(</span><span class="n">allQueues</span><span class="p">),</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">view</span><span class="p">(</span><span class="n">deviceExtensions</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">features</span><span class="p">);</span><span class="w"></span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">tp</span><span class="o">::</span><span class="n">Device</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">application</span><span class="o">-&gt;</span><span class="n">createDevice</span><span class="p">(</span><span class="n">deviceSetup</span><span class="p">);</span><span class="w"></span></pre><div class="m-note m-dim"><p>Tephra&#x27;s queues do not map one-to-one to Vulkan queues. A Vulkan physical device can expose any number of queues, which themselves don&#x27;t necessarily map to the actual hardware queues. Therefore, Tephra offers the user to create as many queues of any supported type. If more queues are requested than what are available, they get assigned to Vulkan queues in a round-robin fashion. The details about the mapping of any particular <a href="structtp_1_1_device_queue.html" class="m-doc">tp::<wbr />DeviceQueue</a> to a Vulkan queue can be queried with <a href="classtp_1_1_physical_device.html#a20f2a45a155a311e5846198bcc72a2bf" class="m-doc">tp::<wbr />PhysicalDevice::<wbr />getQueueTypeInfo</a>.</p></div><p><br /></p><hr/></section></section><section id="ug-resources"><h2><a href="#ug-resources">Resources</a></h2><p>Most meaningful operations that can be done on devices read and write data from objects in memory called &quot;resources&quot;. In Tephra, a resource is either a <a href="classtp_1_1_buffer.html" class="m-doc">tp::<wbr />Buffer</a> or a <a href="classtp_1_1_image.html" class="m-doc">tp::<wbr />Image</a> object. Each describes where the data is stored in memory and how it can be accessed. For buffers that&#x27;s simply a size and optionally a format, but for images that can also be the dimensionality, number of mipmaps, etc. Resource objects can be allocated through <a href="classtp_1_1_device.html#ab1f7c9dd53018893e062d06b01719c97" class="m-doc">tp::<wbr />Device::<wbr />allocateBuffer</a> and <a href="classtp_1_1_device.html#a7e9b856dc12cb80a9e140f6c8f3a0aab" class="m-doc">tp::<wbr />Device::<wbr />allocateImage</a> functions. Their contents are undefined upon being allocated. Destroying them releases the associated memory, though only after Tephra ensures it is no longer being used by the device.</p><p>Commands generally don&#x27;t operate on resource objects directly, but instead through resource views - <a href="classtp_1_1_buffer_view.html" class="m-doc">tp::<wbr />BufferView</a> and <a href="classtp_1_1_image_view.html" class="m-doc">tp::<wbr />ImageView</a>. These act like non-owning references to a range of the parent resource. For example, to use <code>size</code> bytes starting at some <code>offset</code> of a <a href="classtp_1_1_buffer.html" class="m-doc">tp::<wbr />Buffer</a>, you would create a <a href="classtp_1_1_buffer_view.html" class="m-doc">tp::<wbr />BufferView</a> like so: <code class="m-code"><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">getView</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span></code> and then bind the view instead. For convenience, resource views have a very similar interface to the resources themselves and a resource is also implicitly convertible to a default view of its entire range. The idea is that you can be pass these views around in your code whenever you don&#x27;t need the ownership semantics of passing the actual resource.</p><p><br /></p><section id="ug-resources-buffers"><h3><a href="#ug-resources-buffers">Buffers</a></h3><p><a href="classtp_1_1_buffer.html" class="m-doc">tp::<wbr />Buffer</a> represents a one-dimensional resource of a given size. It can be used to store vertex and index buffers, to provide single dimensioned data to shaders or to serve as an intermediate step for copying linear image data to <a href="classtp_1_1_image.html" class="m-doc">tp::<wbr />Image</a> resources.</p><p>Buffers can be created through <a href="classtp_1_1_device.html#ab1f7c9dd53018893e062d06b01719c97" class="m-doc">tp::<wbr />Device::<wbr />allocateBuffer</a> with two parameters. The standard <a href="structtp_1_1_buffer_setup.html" class="m-doc">tp::<wbr />BufferSetup</a> structure takes a size in bytes and a usage mask that specifies how the buffer is going to be used - the rest will not be allowed during the lifetime of the buffer.</p><p>The second parameter describes the types of memory that the buffer may be allocated from. Different devices may have different types of memory available and as such it is important to be able to run your application efficiently on any device. Tephra exposes device memory locations along three different aspects. First, memory can be device-local. Every kind of memory that may be allocated through the library are accessible by the device, but only device-local locations can be used at peak performance. With discrete GPUs, this means the memory is present in VRAM, compared to CPU RAM for non-device-local memory. Second, only host visible memory locations are directly accessible by the host (the CPU). Host-visible memory can also be cached, which helps with host read performance.</p><p>These aspects are combined into 5 distinct <a href="namespacetp.html#a0ae67108bd96881f5af690bbec57c181" class="m-doc">tp::<wbr />MemoryLocation</a> types. <a href="namespacetp.html#a0ae67108bd96881f5af690bbec57c181ab61e4392ba9fbbb214a368e95f1d5582" class="m-doc">tp::<wbr />MemoryLocation::<wbr />DeviceLocal</a> represents the fast memory that only the device can access. <a href="namespacetp.html#a0ae67108bd96881f5af690bbec57c181afac2cffb4f63d7f6f14f36e3113011f2" class="m-doc">tp::<wbr />MemoryLocation::<wbr />DeviceLocalHostVisible</a> and <a href="namespacetp.html#a0ae67108bd96881f5af690bbec57c181a9bd44d8585395ec2444e4dc6781b6ab8" class="m-doc">tp::<wbr />MemoryLocation::<wbr />DeviceLocalHostCached</a> offer the same performance, but also allow direct host-side access, which is ideal, but memory of these types can be of limited size on many systems. Finally, <a href="namespacetp.html#a0ae67108bd96881f5af690bbec57c181aadc80d27025d282563fab5fa234dff99" class="m-doc">tp::<wbr />MemoryLocation::<wbr />HostVisible</a> and <a href="namespacetp.html#a0ae67108bd96881f5af690bbec57c181aa35cfabdf070dbf86b1680bd3a892760" class="m-doc">tp::<wbr />MemoryLocation::<wbr />HostCached</a> usually offer large amounts of host-visible memory, but the buffers allocated from it may be slower to access from the GPU.</p><p>Because the availability of memory locations may differ on different platforms, Tephra offers an additional layer of abstraction here. The second parameter of <a href="classtp_1_1_device.html#ab1f7c9dd53018893e062d06b01719c97" class="m-doc">tp::<wbr />Device::<wbr />allocateBuffer</a> accepts a <a href="structtp_1_1_memory_preference.html" class="m-doc">tp::<wbr />MemoryPreference</a>, which is a sequence of memory locations in the order that they should be prioritized. The buffer will be allocated from the first memory location in the sequence that has available capacity. The chosen location can then be queried with <a href="classtp_1_1_buffer.html#ad09f3bf5312b3e5d8c80d15eb1b70295" class="m-doc">tp::<wbr />Buffer::<wbr />getMemoryLocation</a>. There are a couple of predefined preferences, which should be enough for most use cases:</p><ul><li><a href="structtp_1_1_memory_preference.html#a816b94287a91a37657706e17cd4ad77f" class="m-doc">tp::<wbr />MemoryPreference::<wbr />Device</a> guarantees that only device-local memory will be allocated, otherwise memory allocation error is thrown. This preference should be used when the resource does not need to be directly accessible by the host, but fast access by the device is needed.</li><li><a href="structtp_1_1_memory_preference.html#aa8409352d9ddcd46c98122b6e8e0486b" class="m-doc">tp::<wbr />MemoryPreference::<wbr />Host</a> can be used for resources that should live in host memory. Meant for large data that is being read by the device infrequently and shouldn&#x27;t be wasting the potentially limited device-local, host visible memory. This is the best progression for staging buffers used to copy data to device-local memory.</li><li><a href="structtp_1_1_memory_preference.html#af014d9d59f0c4e0331c346920707fff3" class="m-doc">tp::<wbr />MemoryPreference::<wbr />UploadStream</a> should be used for priority resources that are written to by the host and need to be read by the device with low latency. If device locality is required, the resulting memory location of the allocation should be checked for a potential fallback to be used as a staging buffer.</li><li><a href="structtp_1_1_memory_preference.html#ab75906d99c5164856a08a5856a5cbb2f" class="m-doc">tp::<wbr />MemoryPreference::<wbr />ReadbackStream</a> is to be used for priority resources that are written to by the device and need to be read by the host with low latency.</li></ul><p>Buffers that were allocated from a location that is visible by the host - so all of them besides <a href="namespacetp.html#a0ae67108bd96881f5af690bbec57c181ab61e4392ba9fbbb214a368e95f1d5582" class="m-doc">tp::<wbr />MemoryLocation::<wbr />DeviceLocal</a> - can be mapped for host access with <a href="classtp_1_1_buffer.html#a2922fe5d7595ba0dfe93d202f54d6747" class="m-doc">tp::<wbr />Buffer::<wbr />mapForHostAccess</a>. It returns a <a href="classtp_1_1_host_mapped_memory.html" class="m-doc">tp::<wbr />HostMappedMemory</a> object that provides this access during its lifetime. <a href="classtp_1_1_host_mapped_memory.html#a7b22375362eac61d672106c461d3745e" class="m-doc">tp::<wbr />HostMappedMemory::<wbr />getPtr</a> can be used to finally retrieve an ordinary pointer of the given type and at the given byte offset. The object should be destroyed soon after the access is complete.</p><pre class="m-code"><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">copyDataToBuffer</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">BufferView</span><span class="o">&amp;</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">HostMappedMemory</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">mapForHostAccess</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">MemoryAccess</span><span class="o">::</span><span class="n">WriteOnly</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">memory</span><span class="p">.</span><span class="n">getPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p>Note that the device executes work asynchronously from the host and low-level graphics APIs like Vulkan do not abstract away that fact. Any data you write to a buffer on the CPU that is then further accessed by the GPU must not be overwritten until all of those accesses finish. For uploading temporary or frequently changing data, Tephra offers a safer and more convenient method described in <a href="user-guide.html#ug-submits-job-local-resources" class="m-doc">Job-local resources</a>.</p><p>Regular buffer views can be created through <a href="classtp_1_1_buffer.html#a7aced32920f429944ddb562e272f2305" class="m-doc">tp::<wbr />Buffer::<wbr />getView</a> or <a href="classtp_1_1_buffer_view.html#a93e2484dcf12b329d37efe1e787aaa28" class="m-doc">tp::<wbr />BufferView::<wbr />getView</a>, taking the size and offset in bytes describing the viewed range relative to the parent buffer or view. The offset must be a multiple of <a href="classtp_1_1_buffer.html#a1328e75d47779bcbad60fd865b1c93a4" class="m-doc">tp::<wbr />Buffer::<wbr />getRequiredViewAlignment</a>, which will be at most 256 bytes, and the size must not be greater than the size of the parent buffer or view. Texel buffer views are special buffer views used for binding to a texel or storage texel buffer desciptor. They can be created with <a href="classtp_1_1_buffer.html#a7a734124870af6f998f062d973b47977" class="m-doc">tp::<wbr />Buffer::<wbr />createTexelView</a> or <a href="classtp_1_1_buffer_view.html#a67488c3826e323b569f92c21d49eeebd" class="m-doc">tp::<wbr />BufferView::<wbr />createTexelView</a>, which additionally take a <a href="namespacetp.html#a575466ff8f546f00468d04124cee38b5" class="m-doc">tp::<wbr />Format</a> that determines how the data will be interpreted inside a shader when bound. Texel buffer views may be more expensive to create (involving Vulkan API calls) than regular buffer views (hence <code>createTexelView</code> rather than <code>getTexelView</code>), but are still cheap to copy once created.</p><pre class="m-code"><span class="c1">// Rounds the value to the nearest larger multiple of m.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">roundUpToMultiple</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">((</span><span class="n">v</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Container for vertex and index data</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Mesh</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">vertexData</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">indexData</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Holds vertex and index data for multiple meshes all in a single buffer</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">VertexIndexBuffer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">tp</span><span class="o">::</span><span class="n">Buffer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">tp</span><span class="o">::</span><span class="n">BufferView</span><span class="o">&gt;</span><span class="w"> </span><span class="n">meshVertices</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">tp</span><span class="o">::</span><span class="n">BufferView</span><span class="o">&gt;</span><span class="w"> </span><span class="n">meshIndices</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">VertexIndexBuffer</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">Device</span><span class="o">*</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Mesh</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">meshes</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// For now put the buffer into host-visible memory so we can map and write to it directly.</span>
<span class="w">        </span><span class="c1">// Later on you will see how to use staging buffers to upload data to resources in</span>
<span class="w">        </span><span class="c1">// device-only memory.</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">MemoryPreference</span><span class="o">&amp;</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">MemoryPreference</span><span class="o">::</span><span class="n">UploadStream</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// We can put both vertex and index data in one buffer</span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">BufferUsageMask</span><span class="w"> </span><span class="n">usage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">BufferUsage</span><span class="o">::</span><span class="n">HostMapped</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">BufferUsage</span><span class="o">::</span><span class="n">VertexBuffer</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">            </span><span class="n">tp</span><span class="o">::</span><span class="n">BufferUsage</span><span class="o">::</span><span class="n">IndexBuffer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">alignment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">Buffer</span><span class="o">::</span><span class="n">getRequiredViewAlignment</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">usage</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">bufferSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span>
<span class="w">        </span><span class="c1">// Suballocate all data from one buffer, ensuring correct alignment</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Mesh</span><span class="o">&amp;</span><span class="w"> </span><span class="n">mesh</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">meshes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">bufferSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">roundUpToMultiple</span><span class="p">(</span><span class="n">bufferSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">vertexData</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">alignment</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">bufferSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">roundUpToMultiple</span><span class="p">(</span><span class="n">bufferSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">indexData</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">alignment</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span>
<span class="w">        </span><span class="c1">// Create the buffer now that we know the full size</span>
<span class="w">        </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="o">-&gt;</span><span class="n">allocateBuffer</span><span class="p">({</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">,</span><span class="w"> </span><span class="n">usage</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">memory</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span>
<span class="w">        </span><span class="c1">// Store the views to all sections and write their data</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Mesh</span><span class="o">&amp;</span><span class="w"> </span><span class="n">mesh</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">meshes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">meshVertices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">getView</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">vertexData</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()));</span><span class="w"></span>
<span class="w">            </span><span class="n">copyDataToBuffer</span><span class="p">(</span><span class="n">meshVertices</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span><span class="w"> </span><span class="o">*</span><span class="n">mesh</span><span class="p">.</span><span class="n">vertexData</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">roundUpToMultiple</span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">vertexData</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">alignment</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span>
<span class="w">            </span><span class="n">meshIndices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">getView</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">indexData</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()));</span><span class="w"></span>
<span class="w">            </span><span class="n">copyDataToBuffer</span><span class="p">(</span><span class="n">meshIndices</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span><span class="w"> </span><span class="o">*</span><span class="n">mesh</span><span class="p">.</span><span class="n">indexData</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">roundUpToMultiple</span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">indexData</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">alignment</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span></pre><p><br /></p></section><section id="ug-resources-images"><h3><a href="#ug-resources-images">Images</a></h3><p><a href="classtp_1_1_image.html" class="m-doc">tp::<wbr />Image</a> represents a single or higher-dimensional resource that supports various filtering operations, such as interpolation and mipmapping. Their most common use in computer graphics is as textures and render targets. Unlike buffers, they can only reside in device-local memory, so you don&#x27;t need to specify the memory preference upon creation. This also means they cannot be mapped directly. To upload image data, a staging buffer and a <a href="classtp_1_1_job.html#aba90522bc9701418d2615b9696e8f70b" class="m-doc">tp::<wbr />Job::<wbr />cmdCopyBufferToImage</a> command is needed.</p><p>The <a href="structtp_1_1_image_setup.html" class="m-doc">tp::<wbr />ImageSetup</a> structure makes up for it in terms of available options. <a href="namespacetp.html#a934258f5adba65025b71cc3b7ee994ba" class="m-doc">tp::<wbr />ImageType</a> is the first parameter, determining the dimensionality of the image and the types of image views can be created out of it later. Images can be one, two or three-dimensional. Two-dimensional images can optionally support cubemap views and three-dimensional ones views of each z slice as a 2D layer. The second parameter is the usage mask describing how the image will be used.</p><p>You can also specify the format of the image and the extent in texels across all three dimensions. The values in the extra dimensions beyond the type of the image must be set to 1. Images can also be created with mipmaps, with each level having half the extent of the previous one, rounded up. The number of mip levels and the number of array layers are given next. Note that for 3D images, the number of array levels must be set to 1. 2D images can also have a multisampling level set above x1 for antialiasing purposes.</p><p>Image views can be created with a different format than that of the parent image. To allow that, all the required formats must be listed in the <code>compatibleFormats</code> field. The formats must be in the same <a href="namespacetp.html#a8c768c8069720fcaef48f25d4c28dbd9" class="m-doc">tp::<wbr />FormatCompatibilityClass</a>. <a href="namespacetp.html#a077027235952bce234a98664417291cc" class="m-doc">tp::<wbr />getFormatCompatibilityClass</a> can be used to determine the class of a format. <a href="namespacetp.html#a8bdf44d8b91821627cf97495f3586500" class="m-doc">tp::<wbr />getFormatClassProperties</a> additionally exposes various useful properties of the format class, like the size of a texel block in bytes.</p><p>To create a <a href="classtp_1_1_image_view.html" class="m-doc">tp::<wbr />ImageView</a>, you provide a <a href="namespacetp.html#a0d27ef619231fa3c59ec96267d66a4bd" class="m-doc">tp::<wbr />ImageViewType</a> and a format into a <a href="structtp_1_1_image_view_setup.html" class="m-doc">tp::<wbr />ImageViewSetup</a> structure to determine how the image data should be interpreted. You also specify a <a href="structtp_1_1_image_subresource_range.html" class="m-doc">tp::<wbr />ImageSubresourceRange</a>. The range for buffer views was defined by just an offset and a size, but with image views, it&#x27;s a little more complicated. An image view can reference a range of array layers, a range of mip levels and an &quot;aspect&quot; mask that chooses between depth and stencil for images with the relevant formats.</p><p>The easiest way to specify a subresource range is to call <a href="classtp_1_1_image.html#a32df8cc43a4826df36f524dad5fd5c7b" class="m-doc">tp::<wbr />Image::<wbr />getWholeRange</a> or <a href="classtp_1_1_image_view.html#a6dff90b365271152f22d9d10b12a9253" class="m-doc">tp::<wbr />ImageView::<wbr />getWholeRange</a>. This will return the subresource range encompassing the entire image or view (relative to it, <code>baseMipLevel</code> and <code>baseArrayLevel</code> will always be 0). This range can then be reduced with <a href="structtp_1_1_image_subresource_range.html#a4a3702eada499a8404ed11a0da0bd1e6" class="m-doc">tp::<wbr />ImageSubresourceRange::<wbr />pickLayer</a> or <code>pickLayers</code>, <a href="structtp_1_1_image_subresource_range.html#a7953b70e8bba9ca226ae3fac4addcd2b" class="m-doc">tp::<wbr />ImageSubresourceRange::<wbr />pickMipLevel</a> or <code>pickMipLevels</code>. A subresource range with only one mip level, but potentially multiple array layers is defined as <a href="structtp_1_1_image_subresource_layers.html" class="m-doc">tp::<wbr />ImageSubresourceLayers</a>. A subresource range with only one mip level and one array layer is then <a href="structtp_1_1_image_subresource.html" class="m-doc">tp::<wbr />ImageSubresource</a>. The final parameter is an optional <a href="structtp_1_1_component_mapping.html" class="m-doc">tp::<wbr />ComponentMapping</a>, that can be used to swizzle the image during sampling operations in shaders.</p><pre class="m-code"><span class="k">struct</span><span class="w"> </span><span class="nc">Cubemap</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">tp</span><span class="o">::</span><span class="n">Image</span><span class="o">&gt;</span><span class="w"> </span><span class="n">image</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageView</span><span class="w"> </span><span class="n">cubemapView</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">tp</span><span class="o">::</span><span class="n">ImageView</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sliceViews</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">Cubemap</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">Device</span><span class="o">*</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">faceSize</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">Format</span><span class="w"> </span><span class="n">format</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageUsageMask</span><span class="w"> </span><span class="n">usage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageUsage</span><span class="o">::</span><span class="n">SampledImage</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageUsage</span><span class="o">::</span><span class="n">TransferDst</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">extent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">Extent3D</span><span class="p">(</span><span class="n">faceSize</span><span class="p">,</span><span class="w"> </span><span class="n">faceSize</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Include mipmap chain</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mips</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">log2</span><span class="p">(</span><span class="n">faceSize</span><span class="p">)));</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 6 faces to a cubemap</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">arrayLayerCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span>
<span class="w">        </span><span class="c1">// Create a cubemap-compatible 2D image array</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">setup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageSetup</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">ImageType</span><span class="o">::</span><span class="n">Image2DCubeCompatible</span><span class="p">,</span><span class="w"> </span><span class="n">usage</span><span class="p">,</span><span class="w"> </span><span class="n">format</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">extent</span><span class="p">,</span><span class="w"> </span><span class="n">mips</span><span class="p">,</span><span class="w"> </span><span class="n">arrayLayerCount</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="o">-&gt;</span><span class="n">allocateImage</span><span class="p">(</span><span class="n">setup</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span>
<span class="w">        </span><span class="c1">// Default image view will consider this image as a 2D image array,</span>
<span class="w">        </span><span class="c1">// so create a cubemap view:</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">cubemapViewSetup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageViewSetup</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageViewType</span><span class="o">::</span><span class="n">ViewCube</span><span class="p">,</span><span class="w"> </span><span class="n">image</span><span class="o">-&gt;</span><span class="n">getWholeRange</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="n">cubemapView</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="o">-&gt;</span><span class="n">createView</span><span class="p">(</span><span class="n">cubemapViewSetup</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span>
<span class="w">        </span><span class="c1">// Also create views for each slice:</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">arrayLayerCount</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="n">sliceViewSetup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageViewSetup</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageViewType</span><span class="o">::</span><span class="n">View2D</span><span class="p">,</span><span class="w"> </span><span class="n">image</span><span class="o">-&gt;</span><span class="n">getWholeRange</span><span class="p">().</span><span class="n">pickLayer</span><span class="p">(</span><span class="n">i</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="n">sliceViews</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="o">-&gt;</span><span class="n">createView</span><span class="p">(</span><span class="n">sliceViewSetup</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span></pre><div class="m-note m-dim"><p>Resource views in Tephra are intended to be easy and relatively cheap to create, even image and texel buffer views. This does not directly fit Vulkan&#x27;s model of resource views, which have handles that must be explicitly created and destroyed. To facilitate this, all required view handles are created and owned by their parent resources. They are cached and reused, so requesting the same view twice doesn&#x27;t create any duplicate Vulkan handles. These handles only get destroyed when the parent resource gets destroyed. There is currently no way to clean them up earlier, but this shouldn&#x27;t be an issue for most use cases that only create at most a couple dozen views per image or texel buffer views for buffers.</p></div><p><br /></p><hr/></section></section><section id="ug-submits"><h2><a href="#ug-submits">Submitting work</a></h2><section id="ug-submits-jobs"><h3><a href="#ug-submits-jobs">Jobs</a></h3><p>To have the device perform any kind of work, a <a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a> needs to be created, recorded, enqueued and finally submitted to one of the prepared queues. A job encompasses a sequence of commands to be executed on the device, along with any job-local resources that may be requested for it.</p><p>To create jobs, a <a href="classtp_1_1_job_resource_pool.html" class="m-doc">tp::<wbr />JobResourcePool</a> must be created first. The pool primarily handles efficient allocation of resources for jobs that will be submitted to the same queue. As such, its setup structure only has one required parameter - the queue that any jobs created from this pool are allowed to be submitted to. The other parameters let you specify additional flags or change growth factors for better control over how the pool allocates resources.</p><pre class="m-code"><span class="k">auto</span><span class="w"> </span><span class="n">jobPoolSetup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">JobResourcePoolSetup</span><span class="p">(</span><span class="n">mainQueue</span><span class="p">);</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">tp</span><span class="o">::</span><span class="n">JobResourcePool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mainJobPool</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">device</span><span class="o">-&gt;</span><span class="n">createJobResourcePool</span><span class="p">(</span><span class="n">jobPoolSetup</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Main job pool&quot;</span><span class="p">);</span><span class="w"></span></pre><p>A single job pool should be used repeatedly for many jobs. It works best for similar tasks, like rendering a scene every frame, where each frame&#x27;s jobs use a similar amount of resources that can be efficiently reused from frame to frame. By default, the allocated memory is only released when the pool gets destroyed, but anything that has been unused for a certain amount of time can be released manually by calling <a href="classtp_1_1_job_resource_pool.html#a5258a873d16b53789fef035f09b09340" class="m-doc">tp::<wbr />JobResourcePool::<wbr />trim</a>. It can either be called periodically, after an expensive one-off job, or only when running out of memory. One can query how much memory the pool uses by calling <a href="classtp_1_1_job_resource_pool.html#ac6dbc5ceeda30885d70b7d73fbd6e9c1" class="m-doc">tp::<wbr />JobResourcePool::<wbr />getStatistics</a>, and <a href="classtp_1_1_job_resource_pool.html#a5258a873d16b53789fef035f09b09340" class="m-doc">tp::<wbr />JobResourcePool::<wbr />trim</a> also returns the number of bytes that were freed by the call.</p><p>The pool can be used, through <a href="classtp_1_1_job_resource_pool.html#ae3e43178d4d141772e605e47e13c9c8e" class="m-doc">tp::<wbr />JobResourcePool::<wbr />createJob</a>, to create <a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a> objects that provide an interface for recording high-level commands. Once the needed commands are recorded into the job, it can be enqueued by calling <a href="classtp_1_1_device.html#a1fb94f90c9cd0968b70750ec5be5a41b" class="m-doc">tp::<wbr />Device::<wbr />enqueueJob</a>. Doing so gives up the ownership of the job, so that no more commands can be recorded to it. In exchange, you are given a <a href="structtp_1_1_job_semaphore.html" class="m-doc">tp::<wbr />JobSemaphore</a> handle, which represents a synchronization primitive that becomes signalled when the job finishes executing on the device. It can be waited upon either by the host through <a href="classtp_1_1_device.html#aba627ca9495503070e0e2fb2f2cbfea5" class="m-doc">tp::<wbr />Device::<wbr />waitForJobSemaphores</a> or by another job by passing it as the <code>waitJobSemaphores</code> parameter of <a href="classtp_1_1_device.html#a1fb94f90c9cd0968b70750ec5be5a41b" class="m-doc">tp::<wbr />Device::<wbr />enqueueJob</a>. The execution order of jobs submitted to the same queue is already determined by the order in which they were enqueued, so the use of semaphores on the device is only useful for synchronizing jobs across different queues.</p><p>Enqueued jobs don&#x27;t actually start executing until they have been submitted. To submit all the jobs that have been enqueued to a particular queue so far, call <a href="classtp_1_1_device.html#a93761a656dd28cfb569419c90ff66e3f" class="m-doc">tp::<wbr />Device::<wbr />submitQueuedJobs</a>. Pay in mind that submitting jobs is a relatively expensive operation.</p><pre class="m-code"><span class="c1">// Create and record the job</span>
<span class="n">tp</span><span class="o">::</span><span class="n">Job</span><span class="w"> </span><span class="n">job</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mainJobPool</span><span class="o">-&gt;</span><span class="n">createJob</span><span class="p">({},</span><span class="w"> </span><span class="s">&quot;Example job&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">recordSomeCommands</span><span class="p">(</span><span class="n">job</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Enqueue the job to finalize the recording</span>
<span class="n">tp</span><span class="o">::</span><span class="n">JobSemaphore</span><span class="w"> </span><span class="n">semaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="o">-&gt;</span><span class="n">enqueueJob</span><span class="p">(</span><span class="n">mainQueue</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">job</span><span class="p">));</span><span class="w"></span>

<span class="c1">// Finally submit it for execution and, for demonstration purposes, immediately wait for it to be</span>
<span class="c1">// done on the device</span>
<span class="n">device</span><span class="o">-&gt;</span><span class="n">submitQueuedJobs</span><span class="p">(</span><span class="n">mainQueue</span><span class="p">);</span><span class="w"></span>
<span class="n">device</span><span class="o">-&gt;</span><span class="n">waitForJobSemaphores</span><span class="p">({</span><span class="w"> </span><span class="n">semaphore</span><span class="w"> </span><span class="p">});</span><span class="w"></span></pre><div class="m-note m-dim"><p><a href="structtp_1_1_job_semaphore.html" class="m-doc">tp::<wbr />JobSemaphore</a> represents a value of a Vulkan timeline semaphore. It is considered signalled when the value of the timeline semaphore becomes greater or equal the value given by the <a href="structtp_1_1_job_semaphore.html" class="m-doc">tp::<wbr />JobSemaphore</a>. The values assigned to each job come from a single device-wide counter that gets atomically incremented for every job enqueued to any queue.</p><p>The reason timeline semaphores are used instead of the usual binary semaphores is that the latter is limited to one signal - one wait pair, meaning you would have to specify how many times you will wait on any given semaphore ahead of time, which would be very inconvenient. A single device-wide counter instead of separate counters for each queue make it simple to determine the set of enqueued or submitted jobs that an object could have been used in, simplifying the extension of lifetimes of Vulkan handles, as described by the implementation note in the <a href="user-guide.html#ug-general-concepts-object-lifetime-and-hierarchy" class="m-doc">Object lifetime and hierarchy</a> section.</p></div><p><br /></p></section><section id="ug-submits-job-command-recording"><h3><a href="#ug-submits-job-command-recording">Job command recording</a></h3><p>A <a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a> object has two types of functions. Functions that start with <code>cmd</code> are the command functions. They record work into the job in the order that they are called, which is then the same order that they will be executed in. The other kind of functions serve to create job-local resources, to be discussed in a later section.</p><p>The command recording design in Tephra has two levels. The commands recorded into a <a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a> are the &quot;high-level&quot; commands. They perform some operation on a set of provided resources and their synchronization is managed automatically. These are mainly operations that involve copying, clearing, resolving and exporting resources, but also commands to execute compute and render passes, where the actual work happens. These passes contain command lists into which &quot;low-level&quot; commands can be recorded, such as the binding of pipelines and descriptors, as well as issuing draw calls. Such commands, on the other hand, are designed for very low overhead and multithreaded recording.</p><p>A single pass represents a scope of commands that, from the job&#x27;s point of view, consumes data in a set of resources as input to write some data to another set of resources as output. A render pass defines a set of attachments, aka &quot;render targets&quot;, that its draw commands can render to. For example, rendering a single shadow map will likely be represented as a single render pass with many draw commands inside for drawing all the visible geometry. A tonemapping post-processing pass could also be a render pass with a single draw command for rendering a full-screen quad (or triangle). A compute pass similarly needs to be provided a list of resources that the compute dispatches inside will be writing to. Resources that are only used as input don&#x27;t need to be listed explicitly in render and compute passes, so long as they were exported beforehand with <a href="classtp_1_1_job.html#a967f5a891d8e50cb73d0f6b7c6cec066" class="m-doc">tp::<wbr />Job::<wbr />cmdExportResource</a>.</p><p>The calls to <a href="classtp_1_1_job.html#a3743dd4c6e7f8d56e153290543342afb" class="m-doc">tp::<wbr />Job::<wbr />cmdExecuteComputePass</a> and <a href="classtp_1_1_job.html#a8db1261d6e0e2e9c1536cd50de39b547" class="m-doc">tp::<wbr />Job::<wbr />cmdExecuteRenderPass</a> also need to describe how the commands that are to be executed inside each pass should be recorded. This can be done in two ways. You can provide an array of default-constructed command lists to the call. After it, the array will be populated with valid command lists that will be executed in that order inside the pass. Your responsibility is to then record commands to them, once the job is enqueued, but before it gets submitted. For that you will also need to request a command pool from the job through <a href="classtp_1_1_job.html#a89daeb18ba2053291787120b8327e334" class="m-doc">tp::<wbr />Job::<wbr />createCommandPool</a>. They can be reused between all passes inside the same job, but you must only have one thread using each pool at a time.</p><p>Sometimes the scalability of deferred recording of multiple command lists is overkill if all you want to do is a single draw for your post-processing. For that there is another, more convenient way of recording commands to a pass: Inline callbacks. Instead of providing an array of command lists, you can pass a function that will be called by Tephra to record the commands just-in-time during <a href="classtp_1_1_device.html#a93761a656dd28cfb569419c90ff66e3f" class="m-doc">tp::<wbr />Device::<wbr />submitQueuedJobs</a>. That way, the code that records your job commands and the code that records the pass commands can be kept together.</p><div class="m-note m-dim"><p>As mentioned above, command functions in <a href="classtp_1_1_command_list.html" class="m-doc">tp::<wbr />CommandList</a> are just thin wrappers around the Vulkan API. In fact, you can use <a href="classtp_1_1_command_list.html#a81914d5675d536bb0af390a07bcf89c5" class="m-doc">tp::<wbr />CommandList::<wbr />vkGetCommandBufferHandle</a> to get the Vulkan command buffer and record any commands yourself, which can be especially useful with extensions that Tephra doesn&#x27;t natively support.</p><p>Job command recording is somewhat more interesting. Job commands, along with all their data, get recorded into an internal command buffer. This buffer is composed of 4kB blocks of memory that are allocated as needed. Each command can store arbitrary amounts of data (either stored inline if small enough, otherwise using a separate allocation). These allocations get reused for subsequent jobs created from the same pool.</p><p>This command buffer gets replayed during <a href="classtp_1_1_device.html#a93761a656dd28cfb569419c90ff66e3f" class="m-doc">tp::<wbr />Device::<wbr />submitQueuedJobs</a> two times - once to resolve automatic synchronization and generate barriers, and the second time to record the commands, along with the barriers, to a Vulkan command buffer.</p></div><p><br /></p></section><section id="ug-submits-compute-passes"><h3><a href="#ug-submits-compute-passes">Compute Passes</a></h3><p>Compute passes are the simpler of the two passes that can be executed inside a <a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a>. The <a href="structtp_1_1_compute_pass_setup.html" class="m-doc">tp::<wbr />ComputePassSetup</a> structure only takes a list of <a href="structtp_1_1_buffer_compute_access.html" class="m-doc">tp::<wbr />BufferComputeAccess</a> and a list of <a href="structtp_1_1_image_compute_access.html" class="m-doc">tp::<wbr />ImageComputeAccess</a>. These help provide the necessary information to Tephra about which resources are going to be accessed inside the pass and how. The access structures can be constructed from a view of the resource, optionally limiting it to a subresource range, and a <a href="namespacetp.html#a7f03d242703821957cc6c3ecd0a20ddc" class="m-doc">tp::<wbr />ComputeAccess</a> mask that describes how the resource is going to be used. This must cover <strong>all</strong> of the resource accesses inside the pass, unless the access is read-only and the resource has been previously exported for that access - see the <a href="user-guide.html#ug-submits-synchronization" class="m-doc">Synchronization</a> section. Considering that most read-only resources, like uniform buffers and textures, should end up exported for the sake of this convenience, the most common access value for resources in a compute pass tends to be <a href="namespacetp.html#a7f03d242703821957cc6c3ecd0a20ddca7718c728b626d023eb85610085feac83" class="m-doc">tp::<wbr />ComputeAccess::<wbr />ComputeShaderStorageWrite</a>.</p><p>The second parameter for <a href="classtp_1_1_job.html#a3743dd4c6e7f8d56e153290543342afb" class="m-doc">tp::<wbr />Job::<wbr />cmdExecuteComputePass</a> determines how the commands inside the compute pass are to be recorded. This was talked about in the previous section. You have the option of passing a list of <a href="classtp_1_1_compute_list.html" class="m-doc">tp::<wbr />ComputeList</a> objects that will be initialized by the call and can be recorded to after the job is enqueued. For that, a <a href="classtp_1_1_command_pool.html" class="m-doc">tp::<wbr />CommandPool</a> is needed from <a href="classtp_1_1_job.html#a89daeb18ba2053291787120b8327e334" class="m-doc">tp::<wbr />Job::<wbr />createCommandPool</a>. A command pool is an opaque object that is intended to be passed to <a href="classtp_1_1_compute_list.html#a2461b00f05368227d9fda369d70850fd" class="m-doc">tp::<wbr />ComputeList::<wbr />beginRecording</a> once the job gets enqueued to facilitate the recording. It can be used for multiple compute lists, but it is not thread-safe. Meaning, to record command lists from multiple threads, each thread must pass a different <a href="classtp_1_1_command_pool.html" class="m-doc">tp::<wbr />CommandPool</a> to their command lists. After you have finished recording, but before the job is submitted, <a href="classtp_1_1_compute_list.html#a969c0b1eb83b5b690343215d2ae81a39" class="m-doc">tp::<wbr />ComputeList::<wbr />endRecording</a> must be called. Note that command lists will be executed in the order they were provided in the list, regardless of the order in which they were recorded.</p><p>Alternatively, you can pass a <a href="namespacetp.html#aa35536cf20aa7489b1e861514ec00ea4" class="m-doc">tp::<wbr />ComputeInlineCallback</a> function to <a href="classtp_1_1_job.html#a3743dd4c6e7f8d56e153290543342afb" class="m-doc">tp::<wbr />Job::<wbr />cmdExecuteComputePass</a> instead of a list of compute lists. This callback function will be called during <a href="classtp_1_1_device.html#a93761a656dd28cfb569419c90ff66e3f" class="m-doc">tp::<wbr />Device::<wbr />submitQueuedJobs</a> to record the commands inline. It should accept a <a href="classtp_1_1_compute_list.html" class="m-doc">tp::<wbr />ComputeList</a> as a parameter to record the commands into. In this case, <a href="classtp_1_1_compute_list.html#a2461b00f05368227d9fda369d70850fd" class="m-doc">tp::<wbr />ComputeList::<wbr />beginRecording</a> and <a href="classtp_1_1_compute_list.html#a969c0b1eb83b5b690343215d2ae81a39" class="m-doc">tp::<wbr />ComputeList::<wbr />endRecording</a> must <strong>not</strong> be called.</p><p><a href="classtp_1_1_compute_list.html" class="m-doc">tp::<wbr />ComputeList</a> is, in either case, the main interface for recording low-level commands inside a compute pass. It has commands like <a href="classtp_1_1_compute_list.html#a0b377fe3da1edec80b9a0e81087b0e65" class="m-doc">tp::<wbr />ComputeList::<wbr />cmdBindComputePipeline</a>, <a href="classtp_1_1_command_list.html#a0636227ef981fbd2998c802dd73a8eb2" class="m-doc">tp::<wbr />CommandList::<wbr />cmdBindDescriptorSets</a> and <a href="classtp_1_1_command_list.html#a94bd2a4fe4484aeb003695a6bab5ef15" class="m-doc">tp::<wbr />CommandList::<wbr />cmdPushConstants</a> that modify various current state. This state is local to the command list and starts undefined at first. There will be more on <a href="user-guide.html#ug-pipelines" class="m-doc">Pipelines</a> and <a href="user-guide.html#ug-descriptors" class="m-doc">Resource descriptors</a> later.</p><p>Then there are <a href="classtp_1_1_compute_list.html#a9516223319123c64e738b820f47a9480" class="m-doc">tp::<wbr />ComputeList::<wbr />cmdDispatch</a> and <a href="classtp_1_1_compute_list.html#a1d6af307e7fc185351a250543149e2d5" class="m-doc">tp::<wbr />ComputeList::<wbr />cmdDispatchIndirect</a>. These dispatch a compute pipeline that has been bound previously, using all the descriptor sets and other state that has been set as well. This is finally how you execute meaningful work on the device in the form of a compute shader.</p><p>There can be multiple dispatches inside a single compute pass, but beware that any execution and memory dependencies between the dispatches need to be synchronized manually, such as when a later dispatch reads data written by the previous one. This can be handled by calling <a href="classtp_1_1_compute_list.html#adc3552ffb74d64e5c0b9f02a57fb3587" class="m-doc">tp::<wbr />ComputeList::<wbr />cmdPipelineBarrier</a> between the pair of dispatches. The function takes a list of dependencies, where each dependency is represented by a pair of <a href="namespacetp.html#a7f03d242703821957cc6c3ecd0a20ddc" class="m-doc">tp::<wbr />ComputeAccess</a> masks. The first value are the accesses performed by any of the previous dispatches, the second are the accesses of the following dispatches. Each of those accesses must also be passed to the compute pass setup. Note that atomic accesses don&#x27;t need to be synchronized against each other.</p><p>If manual synchronization seems daunting, you can always split the dispatches into separate compute passes, which will then get handled automatically, as long as the accesses in each pass are defined properly.</p><pre class="m-code"><span class="c1">// Divides v by d and rounds up to the nearest integer</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">divideRoundUp</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Records commands to perform a separable gaussian blur with a compute shader</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SeparableBlur</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">SeparableBlur</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">Device</span><span class="o">*</span><span class="w"> </span><span class="n">device</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Shader pipeline initialization here, see later examples</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Blur the given image in-place using the provided temporary image. Records to the job inline.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">doBlur</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">Job</span><span class="o">&amp;</span><span class="w"> </span><span class="n">job</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageView</span><span class="o">&amp;</span><span class="w"> </span><span class="n">inOutImage</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageView</span><span class="o">&amp;</span><span class="w"> </span><span class="n">tempImage</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Get the size of the image, assume the temporary image is compatible</span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">Extent3D</span><span class="w"> </span><span class="n">extent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inOutImage</span><span class="p">.</span><span class="n">getExtent</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Horizontal pass samples inOutImage and writes to tempImage</span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageComputeAccess</span><span class="w"> </span><span class="n">horizontalPassAccesses</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="n">inOutImage</span><span class="p">,</span><span class="w"> </span><span class="n">inOutImage</span><span class="p">.</span><span class="n">getWholeRange</span><span class="p">(),</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ComputeAccess</span><span class="o">::</span><span class="n">ComputeShaderSampledRead</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="n">tempImage</span><span class="p">,</span><span class="w"> </span><span class="n">tempImage</span><span class="p">.</span><span class="n">getWholeRange</span><span class="p">(),</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ComputeAccess</span><span class="o">::</span><span class="n">ComputeShaderStorageWrite</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">DescriptorSetView</span><span class="w"> </span><span class="n">horizontalPassResources</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">job</span><span class="p">.</span><span class="n">allocateLocalDescriptorSet</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="o">&amp;</span><span class="n">blurPassDescriptorLayout</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">inOutImage</span><span class="p">,</span><span class="w"> </span><span class="n">tempImage</span><span class="w"> </span><span class="p">});</span><span class="w"></span>

<span class="w">        </span><span class="n">job</span><span class="p">.</span><span class="n">cmdExecuteComputePass</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">tp</span><span class="o">::</span><span class="n">ComputePassSetup</span><span class="p">({},</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">view</span><span class="p">(</span><span class="n">horizontalPassAccesses</span><span class="p">)),</span><span class="w"></span>
<span class="w">            </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">tp</span><span class="o">::</span><span class="n">ComputeList</span><span class="o">&amp;</span><span class="w"> </span><span class="n">computeList</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">computeList</span><span class="p">.</span><span class="n">cmdBindComputePipeline</span><span class="p">(</span><span class="n">blurPassPipeline</span><span class="p">);</span><span class="w"></span>

<span class="w">                </span><span class="c1">// Bind inOutImage to input slot, tempImage to output slot</span>
<span class="w">                </span><span class="n">computeList</span><span class="p">.</span><span class="n">cmdBindDescriptorSets</span><span class="p">(</span><span class="n">blurPassPipelineLayout</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">horizontalPassResources</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="w">                </span><span class="c1">// Set the horizontalPass shader push constant to true</span>
<span class="w">                </span><span class="n">computeList</span><span class="p">.</span><span class="n">cmdPushConstants</span><span class="p">(</span><span class="n">blurPassPipelineLayout</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ShaderStage</span><span class="o">::</span><span class="n">Compute</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>

<span class="w">                </span><span class="c1">// In a horizontal pass, each workgroup will blur 256x1 pixels</span>
<span class="w">                </span><span class="n">computeList</span><span class="p">.</span><span class="n">cmdDispatch</span><span class="p">(</span><span class="n">divideRoundUp</span><span class="p">(</span><span class="n">extent</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">ShaderWorkgroupSize</span><span class="p">),</span><span class="w"> </span><span class="n">extent</span><span class="p">.</span><span class="n">height</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="s">&quot;Blur horizontal pass&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Vertical pass samples tempImage and writes back to inOutImage</span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageComputeAccess</span><span class="w"> </span><span class="n">verticalPassAccesses</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="n">tempImage</span><span class="p">,</span><span class="w"> </span><span class="n">tempImage</span><span class="p">.</span><span class="n">getWholeRange</span><span class="p">(),</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ComputeAccess</span><span class="o">::</span><span class="n">ComputeShaderSampledRead</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="n">inOutImage</span><span class="p">,</span><span class="w"> </span><span class="n">inOutImage</span><span class="p">.</span><span class="n">getWholeRange</span><span class="p">(),</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ComputeAccess</span><span class="o">::</span><span class="n">ComputeShaderStorageWrite</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">DescriptorSetView</span><span class="w"> </span><span class="n">verticalPassResources</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">job</span><span class="p">.</span><span class="n">allocateLocalDescriptorSet</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="o">&amp;</span><span class="n">blurPassDescriptorLayout</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">tempImage</span><span class="p">,</span><span class="w"> </span><span class="n">inOutImage</span><span class="w"> </span><span class="p">});</span><span class="w"></span>

<span class="w">        </span><span class="n">job</span><span class="p">.</span><span class="n">cmdExecuteComputePass</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">tp</span><span class="o">::</span><span class="n">ComputePassSetup</span><span class="p">({},</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">view</span><span class="p">(</span><span class="n">verticalPassAccesses</span><span class="p">)),</span><span class="w"></span>
<span class="w">            </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">tp</span><span class="o">::</span><span class="n">ComputeList</span><span class="o">&amp;</span><span class="w"> </span><span class="n">computeList</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">computeList</span><span class="p">.</span><span class="n">cmdBindComputePipeline</span><span class="p">(</span><span class="n">blurPassPipeline</span><span class="p">);</span><span class="w"></span>

<span class="w">                </span><span class="c1">// Bind inOutImage to input slot, tempImage to output slot</span>
<span class="w">                </span><span class="n">computeList</span><span class="p">.</span><span class="n">cmdBindDescriptorSets</span><span class="p">(</span><span class="n">blurPassPipelineLayout</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">verticalPassResources</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="w">                </span><span class="c1">// Set the horizontalPass shader push constant to false</span>
<span class="w">                </span><span class="n">computeList</span><span class="p">.</span><span class="n">cmdPushConstants</span><span class="p">(</span><span class="n">blurPassPipelineLayout</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ShaderStage</span><span class="o">::</span><span class="n">Compute</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span>

<span class="w">                </span><span class="c1">// In a vertical pass, each workgroup will blur 1x256 pixels</span>
<span class="w">                </span><span class="n">computeList</span><span class="p">.</span><span class="n">cmdDispatch</span><span class="p">(</span><span class="n">extent</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">divideRoundUp</span><span class="p">(</span><span class="n">extent</span><span class="p">.</span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">ShaderWorkgroupSize</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="s">&quot;Blur vertical pass&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="c1">// The workgroup size of the shader</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ShaderWorkgroupSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">256</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">PipelineLayout</span><span class="w"> </span><span class="n">blurPassPipelineLayout</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">DescriptorSetLayout</span><span class="w"> </span><span class="n">blurPassDescriptorLayout</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">Pipeline</span><span class="w"> </span><span class="n">blurPassPipeline</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span></pre><p><br /></p></section><section id="ug-submits-render-passes"><h3><a href="#ug-submits-render-passes">Render Passes</a></h3><p>Render passes are the graphics counterpart of compute passes. As mentioned before, a render pass is a collection of consecutive rendering commands that share the same set of attachments, aka render targets. You can draw thousands of objects and millions of triangles within a single render pass, for example when drawing the main camera&#x27;s view to a color and depth buffer, or even just one or two triangles for a full-screen effect.</p><p>To record a render pass, use the <a href="classtp_1_1_job.html#a8db1261d6e0e2e9c1536cd50de39b547" class="m-doc">tp::<wbr />Job::<wbr />cmdExecuteRenderPass</a> command. It asks for a <a href="structtp_1_1_render_pass_setup.html" class="m-doc">tp::<wbr />RenderPassSetup</a> structure that describes what images are to be used as attachments for the render pass, as well as how the images should be treated at the start and end of the pass. Render passes are able to clear and resolve attachments as part of their execution, generally more efficiently than separate commands like <a href="classtp_1_1_job.html#a4aed4f4ac99e3090785561c937170f5b" class="m-doc">tp::<wbr />Job::<wbr />cmdClearImage</a> and <a href="classtp_1_1_job.html#ac74a3929dfcfb91e412f39a1539c09d5" class="m-doc">tp::<wbr />Job::<wbr />cmdResolveImage</a>.</p><p>The <a href="structtp_1_1_depth_stencil_attachment.html" class="m-doc">tp::<wbr />DepthStencilAttachment</a> and <a href="structtp_1_1_color_attachment.html" class="m-doc">tp::<wbr />ColorAttachment</a> structures describe a depth / stencil attachment and a color attachment for use in a render pass, respectively. Besides the actual image view that will be used as the attachment, they also have you specify the load and store operations for the image that will take place at the start and end of the render pass. The <a href="namespacetp.html#aa57e260754413ae9a64d57adb264c384" class="m-doc">tp::<wbr />AttachmentLoadOp</a> determines whether the contents of the image view should cleared to some color, be loaded to preserve its previous contents, or discarded with <code>DontCare</code>. Discarding or clearing are likely going to be the fastest options, but should only be used if you know you won&#x27;t need the existing contents. Similarly, the <a href="namespacetp.html#ae8ae216230f07b1ccb769eac93fa9c3d" class="m-doc">tp::<wbr />AttachmentStoreOp</a> specifies whether the contents need to be accessible after the render pass ends, or if they should also be discarded with <code>DontCare</code>, which can be useful, for example, for a depth buffer that is used just for the depth tests and its contents aren&#x27;t needed afterwards. If you selected the <a href="namespacetp.html#aa57e260754413ae9a64d57adb264c384adc30bc0c7914db5918da4263fce93ad2" class="m-doc">tp::<wbr />AttachmentLoadOp::<wbr />Clear</a> load operation, you also need to provide a valid clear value.</p><p><a href="structtp_1_1_depth_stencil_attachment.html" class="m-doc">tp::<wbr />DepthStencilAttachment</a> has some additional configuration options compared to color attachments. You can promise that the depth / stencil attachment will be used as read-only. That can be useful not just as an optimization, but it can also allow you to safely read that image as a texture at the same time. Since such images may encompass both depth and stencil aspects, the setup structure optionally lets you define load ops, store ops and read-only flags for the depth and stencil separately.</p><p>The attachment setup structures are also the place to request multisampled attachments to be resolved. The <code>resolveImage</code> parameter can be set to another image with identical parameters, just without multisampling, to resolve the multisampled attachment to it at the end of the render pass. <a href="namespacetp.html#a198f24458c6fe67ac726d5e3c4ffdb9a" class="m-doc">tp::<wbr />ResolveMode</a> then allows you to specify what algorithm should be used to resolve it.</p><p>The <a href="structtp_1_1_render_pass_setup.html" class="m-doc">tp::<wbr />RenderPassSetup</a> structure, besides a <a href="structtp_1_1_depth_stencil_attachment.html" class="m-doc">tp::<wbr />DepthStencilAttachment</a> and a list of <a href="structtp_1_1_color_attachment.html" class="m-doc">tp::<wbr />ColorAttachment</a> structures, also takes a list of <a href="structtp_1_1_buffer_render_access.html" class="m-doc">tp::<wbr />BufferRenderAccess</a> and <a href="structtp_1_1_image_render_access.html" class="m-doc">tp::<wbr />ImageRenderAccess</a>, which, similarly to the compute pass, allow you to specify additional unexported resources that will be accessed directly from the shaders. Next, it optionally takes a render area, through which you can promise to the implementation that you will only render to a smaller rectangular area of the attachments. By default, the entire extent of the views is used, but in the case of a render pass with no attachments, the render area must be defined. For multi-view rendering support, there is also the option to render to more than one layer, which can be selected through shader-specific methods, or have the entire geometry be duplicated to multiple layers by setting the <code>viewMask</code> parameter to a non-zero value.</p><p>Recording commands is similar to compute passes and was described in the previous section. The main differences is that we are using <a href="classtp_1_1_render_list.html" class="m-doc">tp::<wbr />RenderList</a> instead of a <a href="classtp_1_1_compute_list.html" class="m-doc">tp::<wbr />ComputeList</a>. <a href="classtp_1_1_render_list.html" class="m-doc">tp::<wbr />RenderList</a> offers various drawing commands, as well as additional stateful commands besides the usual pipeline and descriptor set binding. Notably, before any draws are issued, the viewport and scissor regions must be set with <a href="classtp_1_1_render_list.html#ae5867b99343daf5dfd928061cb823742" class="m-doc">tp::<wbr />RenderList::<wbr />cmdSetViewport</a> and <a href="classtp_1_1_render_list.html#ae379788e99e14cf808b774928f84ab24" class="m-doc">tp::<wbr />RenderList::<wbr />cmdSetScissor</a>. It is likely you will also need to bind an index and a vertex buffer, for which there are commands, too. If your graphics pipeline has any dynamic state, there are functions for setting that dynamically into the render list as well. All this state is local to the render list. Every list starts with its state undefined and needs to have it set up separately.</p><pre class="m-code"><span class="c1">// Showcase of a simple render pass with a multisampled color and depth buffer with resolve</span>
<span class="k">class</span><span class="w"> </span><span class="nc">RenderPassExample</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">RenderPassExample</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">MultisampleLevel</span><span class="w"> </span><span class="n">multisampleLevel</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">multisampleLevel</span><span class="p">(</span><span class="n">multisampleLevel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Assume we&#39;re always dealing with multisampling in this example</span>
<span class="w">        </span><span class="n">assert</span><span class="p">(</span><span class="n">multisampleLevel</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">MultisampleLevel</span><span class="o">::</span><span class="n">x1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Prepares a pipeline for use in this render pass</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">setupPipeline</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">GraphicsPipelineSetup</span><span class="o">&amp;</span><span class="w"> </span><span class="n">setup</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Set pipeline attachment formats and our multisample level</span>
<span class="w">        </span><span class="n">setup</span><span class="p">.</span><span class="n">setDepthStencilAttachment</span><span class="p">(</span><span class="n">depthFormat</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">setup</span><span class="p">.</span><span class="n">setColorAttachments</span><span class="p">({</span><span class="w"> </span><span class="n">colorFormat</span><span class="w"> </span><span class="p">});</span><span class="w"></span>

<span class="w">        </span><span class="n">setup</span><span class="p">.</span><span class="n">setMultisampling</span><span class="p">(</span><span class="n">multisampleLevel</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// We could also set other pipeline settings here that will be common to the render pass,</span>
<span class="w">        </span><span class="c1">// like blending modes or multi-view rendering</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Adds the render pass to the job and allocates resources for it</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">setupPass</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">Job</span><span class="o">&amp;</span><span class="w"> </span><span class="n">job</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageView</span><span class="o">&amp;</span><span class="w"> </span><span class="n">resolvedImage</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">assert</span><span class="p">(</span><span class="n">resolvedImage</span><span class="p">.</span><span class="n">getFormat</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">colorFormat</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Create the extra attachments as job-local images, see the next chapter for details</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">imageSetup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageSetup</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">ImageType</span><span class="o">::</span><span class="n">Image2D</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageUsage</span><span class="o">::</span><span class="n">ColorAttachment</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">colorFormat</span><span class="p">,</span><span class="w"> </span><span class="n">resolvedImage</span><span class="p">.</span><span class="n">getExtent</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">multisampleLevel</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageView</span><span class="w"> </span><span class="n">colorImage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">job</span><span class="p">.</span><span class="n">allocateLocalImage</span><span class="p">(</span><span class="n">imageSetup</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Multisampled color&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">imageSetup</span><span class="p">.</span><span class="n">usage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageUsage</span><span class="o">::</span><span class="n">DepthStencilAttachment</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">imageSetup</span><span class="p">.</span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">depthFormat</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageView</span><span class="w"> </span><span class="n">depthImage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">job</span><span class="p">.</span><span class="n">allocateLocalImage</span><span class="p">(</span><span class="n">imageSetup</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Multisampled depth&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Let&#39;s clear the images as part of the render pass</span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">ClearValue</span><span class="w"> </span><span class="n">clearColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ClearValue</span><span class="o">::</span><span class="n">ColorFloat</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">ClearValue</span><span class="w"> </span><span class="n">clearDepth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ClearValue</span><span class="o">::</span><span class="n">DepthStencil</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// We clear the depth and color images, but we don&#39;t need the data after the render pass</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">depthAttachment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">DepthStencilAttachment</span><span class="p">(</span><span class="n">depthImage</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">tp</span><span class="o">::</span><span class="n">AttachmentLoadOp</span><span class="o">::</span><span class="n">Clear</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">AttachmentStoreOp</span><span class="o">::</span><span class="n">DontCare</span><span class="p">,</span><span class="w"> </span><span class="n">clearDepth</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// We resolve the color attachment</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">colorAttachment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ColorAttachment</span><span class="p">(</span><span class="n">colorImage</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">tp</span><span class="o">::</span><span class="n">AttachmentLoadOp</span><span class="o">::</span><span class="n">Clear</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">AttachmentStoreOp</span><span class="o">::</span><span class="n">DontCare</span><span class="p">,</span><span class="w"> </span><span class="n">clearColor</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">resolvedImage</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ResolveMode</span><span class="o">::</span><span class="n">Average</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Record the render pass, no additional non-attachment accesses to declare</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">renderPassSetup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">RenderPassSetup</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">depthAttachment</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">viewOne</span><span class="p">(</span><span class="n">colorAttachment</span><span class="p">),</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="p">{});</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Record to a list this time, rather than using an inline callback</span>
<span class="w">        </span><span class="n">job</span><span class="p">.</span><span class="n">cmdExecuteRenderPass</span><span class="p">(</span><span class="n">renderPassSetup</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">viewOne</span><span class="p">(</span><span class="n">renderList</span><span class="p">)</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="w">        </span><span class="c1">// We&#39;ll need a command pool for that</span>
<span class="w">        </span><span class="n">commandPool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">job</span><span class="p">.</span><span class="n">createCommandPool</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Draws objects to the prepared renderList after setupPass gets called and the job is enqueued,</span>
<span class="w">    </span><span class="c1">// but before it is submitted</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">drawObjects</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">objects</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">Viewport</span><span class="w"> </span><span class="n">viewport</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">Rect2D</span><span class="w"> </span><span class="n">scissor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">renderList</span><span class="p">.</span><span class="n">beginRecording</span><span class="p">(</span><span class="n">commandPool</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">renderList</span><span class="p">.</span><span class="n">cmdSetViewport</span><span class="p">({</span><span class="w"> </span><span class="n">viewport</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="w">        </span><span class="n">renderList</span><span class="p">.</span><span class="n">cmdSetScissor</span><span class="p">({</span><span class="w"> </span><span class="n">scissor</span><span class="w"> </span><span class="p">});</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Object</span><span class="o">&amp;</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">objects</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Object&#39;s draw method here is responsible for binding pipelines compatible with the</span>
<span class="w">            </span><span class="c1">// render pass (ones that called setupPipeline)</span>
<span class="w">            </span><span class="n">object</span><span class="p">.</span><span class="n">Draw</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">renderList</span><span class="p">.</span><span class="n">endRecording</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">Format</span><span class="w"> </span><span class="n">depthFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">Format</span><span class="o">::</span><span class="n">DEPTH32_D32_SFLOAT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">Format</span><span class="w"> </span><span class="n">colorFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">Format</span><span class="o">::</span><span class="n">COL32_B8G8R8A8_UNORM</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">MultisampleLevel</span><span class="w"> </span><span class="n">multisampleLevel</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">CommandPool</span><span class="o">*</span><span class="w"> </span><span class="n">commandPool</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">RenderList</span><span class="w"> </span><span class="n">renderList</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span></pre><p><br /></p></section><section id="ug-submits-job-local-resources"><h3><a href="#ug-submits-job-local-resources">Job-local resources</a></h3><p>While the Tephra device provides means to allocate persistent resources that can be used at any time until they are destroyed, a <a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a> allows the user to allocate resources that can only be used within that job. This comes with several advantages - they are more convenient than having to manage temporary resources yourself, and they also come with performance and memory usage benefits due to various sub-allocation and reuse strategies. Job-local resources are automatically reused between jobs allocated from the same job resource pool. This can happen even within the same job: If two similar job-local resources allocated in the same job aren&#x27;t being used at the same time (by two overlapping ranges of commands), then the same Vulkan resource may be used for both, leading to reduced overall memory usage.</p><p>Job-local buffers, images and descriptor sets can only be used within the scope of the job they were allocated from. The cannot be used in commands of other jobs and job-local buffers and images cannot be exported to other queues. They also internally don&#x27;t get created until the job gets enqueued. The visible consequence of this is that persistent descriptor sets can only be created out of job-local resources after the parent job has been enqueued. Job-local descriptor sets exist to circumvent this problem, as their creation is also deferred to when the job gets enqueued.</p><p>Pre-initialized buffers, on the other hand, are created the moment they are allocated from the job and are primarily meant to be used for conveniently uploading data to the device. They can serve either as temporary staging buffers with data that just gets copied over to an image, or for other kinds of data that is only useful in this job, such as shader constants. The lifetime of pre-initialized buffers still ends when the job finishes executing and their memory cannot be safely accessed after the job has been submitted. For that reason they are not suitable for any readback of data to the host, where persistent buffers must be used. See also <a href="user-guide.html#ug-utilities-growable-ring-buffer" class="m-doc">Growable ring buffer</a>.</p><p>Otherwise, <a href="classtp_1_1_job.html#a10e5565ef8b6c2553c9d4572ac223852" class="m-doc">tp::<wbr />Job::<wbr />allocateLocalBuffer</a>, <a href="classtp_1_1_job.html#a65f36e2c51ae63531c0f0ada99ac4f58" class="m-doc">tp::<wbr />Job::<wbr />allocateLocalImage</a> and <a href="classtp_1_1_job.html#ae59e1c14bc1cd1e7ecc2aa403d134a23" class="m-doc">tp::<wbr />Job::<wbr />allocatePreinitializedBuffer</a> are very similar to the <a href="classtp_1_1_device.html" class="m-doc">tp::<wbr />Device</a> resource allocation methods, with the main exception that they return views to the resource, rather than an owning handle. This is both because the resources are owned by the job and because these resources get sub-allocated for efficiency, meaning the resource view you get can only be a part of a full resource.</p><p>The way job-local and pre-initialized resources get allocated and aliased can be controlled through the <a href="structtp_1_1_job_resource_pool_setup.html" class="m-doc">tp::<wbr />JobResourcePoolSetup</a> that was used to create the job. An important reminder - by default the memory used for job-local and pre-initialized resources doesn&#x27;t get freed until the <a href="classtp_1_1_job_resource_pool.html" class="m-doc">tp::<wbr />JobResourcePool</a> is destroyed, but it can be trimmed at any point to reclaim some (or all) of it.</p><pre class="m-code"><span class="c1">// Records commands to the given job to upload data to the first mip level of the image and</span>
<span class="c1">// generates the rest of the mip chain.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">uploadTex</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">Job</span><span class="o">&amp;</span><span class="w"> </span><span class="n">job</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageView</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Allocate a temporary staging buffer for the job.</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">stagingBufferSetup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">BufferSetup</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">BufferUsage</span><span class="o">::</span><span class="n">HostMapped</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">BufferUsage</span><span class="o">::</span><span class="n">ImageTransfer</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">BufferView</span><span class="w"> </span><span class="n">stagingBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">job</span><span class="p">.</span><span class="n">allocatePreinitializedBuffer</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">stagingBufferSetup</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">MemoryPreference</span><span class="o">::</span><span class="n">Host</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Copy the data to the staging buffer. Can also be done later, at any point until the job</span>
<span class="w">        </span><span class="c1">// gets submitted.</span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">HostMappedMemory</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stagingBuffer</span><span class="p">.</span><span class="n">mapForHostAccess</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">MemoryAccess</span><span class="o">::</span><span class="n">WriteOnly</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">memcpy</span><span class="p">(</span><span class="n">memory</span><span class="p">.</span><span class="n">getPtr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Record a command to copy the data to the first mip level of the image.</span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageSubresourceRange</span><span class="w"> </span><span class="n">imageRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">getWholeRange</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">copyRegion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">BufferImageCopyRegion</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">imageRange</span><span class="p">.</span><span class="n">pickMipLevel</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">Offset3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">getExtent</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">job</span><span class="p">.</span><span class="n">cmdCopyBufferToImage</span><span class="p">(</span><span class="n">stagingBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">copyRegion</span><span class="w"> </span><span class="p">});</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Build mipmap chain by blitting to each mip level from the last.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">targetMip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">targetMip</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">imageRange</span><span class="p">.</span><span class="n">mipLevelCount</span><span class="p">;</span><span class="w"> </span><span class="n">targetMip</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">sourceMip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">targetMip</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">blitRegion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageBlitRegion</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">imageRange</span><span class="p">.</span><span class="n">pickMipLevel</span><span class="p">(</span><span class="n">sourceMip</span><span class="p">),</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">getExtent</span><span class="p">(</span><span class="n">sourceMip</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="n">imageRange</span><span class="p">.</span><span class="n">pickMipLevel</span><span class="p">(</span><span class="n">targetMip</span><span class="p">),</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">getExtent</span><span class="p">(</span><span class="n">targetMip</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">job</span><span class="p">.</span><span class="n">cmdBlitImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">blitRegion</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Export it for reading it as a texture</span>
<span class="w">    </span><span class="n">job</span><span class="p">.</span><span class="n">cmdExportResource</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ReadAccess</span><span class="o">::</span><span class="n">FragmentShaderSampled</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><div class="m-note m-dim"><p>The job-local resource implementation needs to do the following to optimize for memory usage and performance:</p><ul><li>Recycling: The backing resources should be reused in subsequent jobs created from the same pool. Creating Vulkan resources is potentially expensive and recycling allows to have zero such allocations on stable periodic workloads.</li><li>Suballocation: Multiple compatible requested resources should be served by a single backing resource to further reduce overhead.</li><li>Aliasing: If multiple compatible requested resources aren&#x27;t being used at the same time, they can be assigned to the same region of a backing resource. This can reduce memory usage over a naive approach, potentially at the cost of additional synchronization. Tephra aliases on the resource level, rather than on the memory level.</li></ul><p>Job-local buffers and images implement all three. The suballocation of images works over layers. If you request two identical job-local images, then Tephra will create a single <code>VkImage</code> resource with two layers, if possible, and the images cannot be aliased together into just one layer. The <a href="namespacetp.html#a050e911cb1725a2d06fe0d4ed5072351ae255bddece7d63893d77252bf20c7c59" class="m-doc">tp::<wbr />JobResourcePoolFlag::<wbr />AliasCompatibleFormats</a> flag allows suballocating images that differ in format, as long as they are from the same format compatibility class. Suballocation and aliasing can be disabled altogether with <a href="namespacetp.html#a050e911cb1725a2d06fe0d4ed5072351a8475058aa9d7bb72629e4c5ece818eed" class="m-doc">tp::<wbr />JobResourcePoolFlag::<wbr />DisableSuballocation</a>.</p><p>Each command recorded into a job that operates on a job-local resource marks that resource with the command&#x27;s index. Each such resource of a job then keeps the minimum and maximum indices of the commands they were used in, which defines the usage range of the resource. Export operations are special and leave the maximum index unbound.</p><p>Requested resources are first sorted into &quot;backing groups&quot; by compatibility. Each group has a list of backing resources that are used to fulfill the requests. Those requests are allocated from the backing resources with respect to their usage range. The algorithm for this is contained in the <code>AliasingSuballocator</code> class. Since it is a greedy algorithm, the list of requested resources are first sorted by size in a descending order, so that the large resources are allocated first and don&#x27;t have large allocations &quot;stolen&quot; from them by small resources. The algorithm then assigns each resource, one by one, to the leftmost available space that it fits in. Anything left over will prompt the creation of a new backing resource. Recycling works trivially, since jobs allocated from the same pool can never overlap.</p><p>Pre-initialized resources work somewhat differently, since their lifetime starts at the moment of the <a href="classtp_1_1_job.html#ae59e1c14bc1cd1e7ecc2aa403d134a23" class="m-doc">tp::<wbr />Job::<wbr />allocatePreinitializedBuffer</a> call, rather than when the job starts executing on the device. That means there is no opportunity for aliasing, but on the other hand the recycling becomes more complex. At the heart of this allocator stands the <a href="classtp_1_1utils_1_1_growable_ring_buffer.html" class="m-doc">tp::<wbr />utils::<wbr />GrowableRingBuffer</a>, which is useful enough that it is also exposed separately as a utility. It is composed of several backing buffers that individually function just like regular ring buffers. When one runs out of space, the allocator switches to the next one that is free. The available space can then be grown just by adding another backing buffer. Allocations are tracked, so that they can be freed in the same order that they were allocated in.</p><p>The pre-initialized buffers can only be released for recycling once the job finishes executing on the device. This is why we are using ring buffers, but care must be taken to allow recording multiple jobs from the same pool at the same time and enqueuing them in any order. In that case we can&#x27;t rely on the buffers becoming available in allocation order. To resolve this, each job claims exclusive access to its <a href="classtp_1_1utils_1_1_growable_ring_buffer.html" class="m-doc">tp::<wbr />utils::<wbr />GrowableRingBuffer</a> until it is enqueued. Any requests from other jobs during that time must create a new buffer. In some situations this can waste memory, so caution is recommended when recording multiple jobs that were allocated from the same pool simultaneously.</p></div><p><br /></p></section><section id="ug-submits-synchronization"><h3><a href="#ug-submits-synchronization">Synchronization</a></h3><p>Within the scope of a job, Tephra synchronizes accesses fully automatically, like in OpenGL. Beyond it, however, it needs some help from the user. We&#x27;ve already discussed <a href="structtp_1_1_job_semaphore.html" class="m-doc">tp::<wbr />JobSemaphore</a>, which synchronizes the execution of jobs. Every <a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a> signals a <a href="structtp_1_1_job_semaphore.html" class="m-doc">tp::<wbr />JobSemaphore</a> that any other job can wait upon before its execution starts. Any job that relies on the results of another job that was submitted to a different queue must wait on its semaphore.</p><p>Another such responsibility on the side of the user is to describe the accesses of resources that happen inside command lists, which the library does not analyze for performance reasons. However, even this is not as daunting as it may seem. It was mentioned that render and compute passes need a list of resources that they will access and how. The library also has a more convenient way that declares read-only accesses for <em>all</em> future passes - job export operations.</p><p><a href="classtp_1_1_job.html#a967f5a891d8e50cb73d0f6b7c6cec066" class="m-doc">tp::<wbr />Job::<wbr />cmdExportResource</a> can be recorded after you write some data to a resource to notify Tephra how you intend to read that data in the future. You can only specify read-only accesses for the resource, and accessing the resource in any other way afterwards will invalidate the export. With a resource exported, you can use it in the provided way without having to specify it in each pass that wishes to access it, even across different jobs. Exports are very useful in the majority of cases where you write to a resource rarely and then read from it many times after. For convenience, the <a href="structtp_1_1_descriptor_binding.html#af7122d7a189d3d1082a35403c960b73f" class="m-doc">tp::<wbr />DescriptorBinding::<wbr />getReadAccessMask</a> function returns the mask of all read accesses that can be performed through that binding. Consider this pseudocode example:</p><pre class="m-code"><span class="n">tp</span><span class="o">::</span><span class="n">ImageView</span><span class="w"> </span><span class="n">texture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">job</span><span class="p">.</span><span class="n">allocateLocalImage</span><span class="p">(</span><span class="n">setup</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Render something to the texture and bind it for use in future shaders.</span>
<span class="c1">// The implementation of these functions isn&#39;t important for now.</span>
<span class="n">renderToTexture</span><span class="p">(</span><span class="n">job</span><span class="p">,</span><span class="w"> </span><span class="n">texture</span><span class="p">);</span><span class="w"></span>
<span class="n">bindTexture</span><span class="p">(</span><span class="n">binding</span><span class="p">,</span><span class="w"> </span><span class="n">texture</span><span class="p">);</span><span class="w"></span>

<span class="c1">// The above is all you would need to do in traditional APIs, but Tephra also requires an export operation</span>
<span class="c1">// to expose the results of the rendering to a set of read accesses, in this case to the binding:</span>
<span class="n">job</span><span class="p">.</span><span class="n">cmdExportResource</span><span class="p">(</span><span class="n">texture</span><span class="p">,</span><span class="w"> </span><span class="n">binding</span><span class="p">.</span><span class="n">getReadAccessMask</span><span class="p">());</span><span class="w"></span>

<span class="c1">// Now we can do some other renders that use the above texture through the binding, or any other binding</span>
<span class="c1">// of the same type.</span>
<span class="n">renderToScreen</span><span class="p">(</span><span class="n">job</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Let&#39;s say later on we want to copy from this texture, which is an access we haven&#39;t exported to.</span>
<span class="c1">// For job commands like this one, that is still legal, but it invalidates the above export.</span>
<span class="n">job</span><span class="p">.</span><span class="n">cmdCopyImage</span><span class="p">(</span><span class="n">texture</span><span class="p">,</span><span class="w"> </span><span class="n">someOtherTexture</span><span class="p">,</span><span class="w"> </span><span class="n">regions</span><span class="p">);</span><span class="w"></span>

<span class="c1">// We must re-export now to allow accessing the texture through the binding again</span>
<span class="n">job</span><span class="p">.</span><span class="n">cmdExportResource</span><span class="p">(</span><span class="n">texture</span><span class="p">,</span><span class="w"> </span><span class="n">binding</span><span class="p">.</span><span class="n">getReadAccessMask</span><span class="p">());</span><span class="w"></span></pre><p>Exports are also needed when you want to access the contents of a resource from a different queue than the one that has last written to it, even with all the proper semaphore synchronization. A cross-queue export just takes an extra parameter, specifying the queue type that the contents should be exported to. After that, the resource and its data can be accessed from any queue of that type, as long as it was also properly synchronized with a semaphore. Invalidating the export, such as by accessing the resource through a different access type, will make the resource&#x27;s contents inaccessible to other queues again. A cross-queue export with an empty access mask is therefore enough to just transfer ownership to another queue.</p><p>Note that an export is needed even if the queue types of the reader and the writer queue match. A situation where an export isn&#x27;t required is the case where the current contents of the resource aren&#x27;t important and can be discarded. The export may be omitted then, but semaphore synchronization is still necessary.</p><p>The last use of an export operation is for readback of data to the CPU. To be able to read back the contents of a buffer in host-visible memory, you must export it with the <a href="namespacetp.html#a2a231ee79583b288a3be330f401bf174ac2ca16d048ec66e04bca283eab048ec2" class="m-doc">tp::<wbr />ReadAccess::<wbr />Host</a> access and ensure the job doing the export has finished executing, either through <a href="classtp_1_1_device.html#a0455917394375f8fd22472c5dcaeb972" class="m-doc">tp::<wbr />Device::<wbr />isJobSemaphoreSignalled</a> or <a href="classtp_1_1_device.html#aba627ca9495503070e0e2fb2f2cbfea5" class="m-doc">tp::<wbr />Device::<wbr />waitForJobSemaphores</a>. Only then you may map the memory and safely read the up-to-date data.</p><p>As a potential optimization for <a href="classtp_1_1_image.html" class="m-doc">tp::<wbr />Image</a> resources, you may also call <a href="classtp_1_1_job.html#aff9e156e1c971a4d2f43018a759202d0" class="m-doc">tp::<wbr />Job::<wbr />cmdDiscardContents</a> to hint at Tephra that the current contents of the image are not needed and can be discarded.</p><div class="m-note m-dim"><p>These paragraphs contain a brief explanation of how automatic synchronization is handled in Tephra. Knowledge of Vulkan synchronization concepts is assumed. If you aren&#x27;t familiar with Vulkan semaphores and barriers, feel free to skip this section.</p><p>Let&#x27;s first consider the synchronization needed within the scope of a single <a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a>. We need a relevant barrier between each pair of commands that access the same resources. For most commands these are known inputs, and for compute and render passes they are provided by the user. After an export operation to the current queue type, we add a barrier between the last use of the resource and the first compute or render pass following the export (or the end of the job).</p><p>To do this, we track certain state for each resource in what is called an access map. It stores, for any subresource range, information about the last accesses made to it, as well as what barriers were already used to synchronize them, if any. The latter allows us to re-use existing barriers efficiently. To process the next command, we first find any previous accesses that intersect the command&#x27;s accesses to the resource and extend the barrier list with the proper synchronization between them. Afterwards, we update the access map with the new accesses to sync any future commands.</p><p>There are usually multiple ways two accesses can be synchronized in the presence of other commands and barriers in between. Tephra tries to minimize the number of pipeline barriers and otherwise inserts any new barriers as late as possible in the command buffer. It does not attempt to reorder the commands, as that is best left in the hands of the user. After we know what barriers to insert and where, we iterate over the job&#x27;s commands again, but this time we translate them to Vulkan commands into the job&#x27;s primary command buffer while inserting the appropriate barriers. This is also when inline callbacks of compute and render passes get invoked.</p><p>The access maps are kept persistent within each queue, so that we can also naturally ensure correct synchronization against accesses of previous jobs in the same queue. When it comes to accessing resources from other queues, we need the appropriate export operation to be able to properly communicate the correct image layouts and potentially issue special queue family ownership transfer barriers. This is done through simple message passing between queues. Each one has its own access maps with local state, but on export it can broadcast a part of that state of a particular resource range to all queues of the chosen queue type. The queues consume these broadcasts at the start of every submit, updating their own access map.</p></div><p><br /></p><hr/></section></section><section id="ug-descriptors"><h2><a href="#ug-descriptors">Resource descriptors</a></h2><section id="ug-descriptors-layouts"><h3><a href="#ug-descriptors-layouts">Descriptor set layouts</a></h3><p>Descriptors in Vulkan, and by extension in Tephra, facilitate the binding of resources for use in shaders. Rather than binding resources one at a time, you create and bind entire sets at once. Multiple descriptor sets can be bound at the same time, which is why resource bindings are identified by both their descriptor set number and the binding index inside that set. All resource bindings declared in a shader must also be defined by a <a href="classtp_1_1_descriptor_set_layout.html" class="m-doc">tp::<wbr />DescriptorSetLayout</a> for each of the sets with a matching <a href="structtp_1_1_descriptor_binding.html" class="m-doc">tp::<wbr />DescriptorBinding</a> struct.</p><p>To create a <a href="classtp_1_1_descriptor_set_layout.html" class="m-doc">tp::<wbr />DescriptorSetLayout</a>, you pass a list of these <a href="structtp_1_1_descriptor_binding.html" class="m-doc">tp::<wbr />DescriptorBinding</a> structs to <a href="classtp_1_1_device.html#afbd384e7dd4404796818f72625356f6f" class="m-doc">tp::<wbr />Device::<wbr />createDescriptorSetLayout</a>. Each of those describes one resource binding as it is used in a shader. A <a href="structtp_1_1_descriptor_binding.html" class="m-doc">tp::<wbr />DescriptorBinding</a> is composed of a binding number that together with the descriptor set number identifies the binding, the <a href="namespacetp.html#a3dccbef68c07e939a1f37825018d2c67" class="m-doc">tp::<wbr />DescriptorType</a> matching the type of the resource binding in the shader, the array size and a stage mask specifying which shader stages the binding can be accessed from. For example, a texture declared in a GLSL fragment shader as <code class="m-code"><span class="k">layout</span><span class="w"> </span><span class="p">(</span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">,</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="kt">sampler2D</span><span class="w"> </span><span class="n">tex</span><span class="p">;</span><span class="w"></span></code> can be in Tephra represented as <code class="m-code"><span class="n">tp</span><span class="o">::</span><span class="n">DescriptorBinding</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">DescriptorType</span><span class="o">::</span><span class="n">CombinedImageSampler</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ShaderStage</span><span class="o">::</span><span class="n">Fragment</span><span class="p">)</span><span class="w"></span></code> when creating a layout for the set 0. The order of descriptor bindings passed to <a href="classtp_1_1_device.html#afbd384e7dd4404796818f72625356f6f" class="m-doc">tp::<wbr />Device::<wbr />createDescriptorSetLayout</a> can be arbitrary, but the same order then must be respected when creating descriptor sets for that layout.</p><p>A <a href="classtp_1_1_pipeline_layout.html" class="m-doc">tp::<wbr />PipelineLayout</a> can then be created out of a list of <a href="classtp_1_1_descriptor_set_layout.html" class="m-doc">tp::<wbr />DescriptorSetLayout</a> objects with <a href="classtp_1_1_device.html#a28a9c08a3b4f90add2d86cb9ed4e1924" class="m-doc">tp::<wbr />Device::<wbr />createPipelineLayout</a>. Their order in the list then determines the descriptor set number of their bindings. Another optional parameter is a list of <a href="structtp_1_1_push_constant_range.html" class="m-doc">tp::<wbr />PushConstantRange</a> structs. Push constants provide efficient means to pass a very small amount of data (usually under 128 bytes, query device properties for limits) to shaders without having to do any descriptor set bindings. A <a href="classtp_1_1_pipeline_layout.html" class="m-doc">tp::<wbr />PipelineLayout</a> is later used for creating pipelines and binding descriptor sets.</p><p><br /></p></section><section id="ug-descriptors-sets"><h3><a href="#ug-descriptors-sets">Descriptor sets</a></h3><p>With descriptor set layouts in hand, we can look at how to actually allocate and bind <a href="classtp_1_1_descriptor_set.html" class="m-doc">tp::<wbr />DescriptorSet</a> objects. In Tephra, descriptor sets represent an immutable set of descriptors given at creation that can then be bound as a single unit. A descriptor is a simple wrapper around either a buffer view, an image view or an image view with an attached sampler.</p><p>Descriptor sets are allocated from a <a href="classtp_1_1_descriptor_pool.html" class="m-doc">tp::<wbr />DescriptorPool</a>, which can be created with <a href="classtp_1_1_device.html#a39b93e3ea48231a3e736779ff30346bc" class="m-doc">tp::<wbr />Device::<wbr />createDescriptorPool</a>. Beware that the descriptor pool, like any other pool isn&#x27;t thread safe and descriptor sets can be allocated from it by only one thread at a time. Finally, you can call <a href="classtp_1_1_descriptor_pool.html#af396ec97357d30ea3a4a04cfc9f928ab" class="m-doc">tp::<wbr />DescriptorPool::<wbr />allocateDescriptorSets</a> to allocate a number of descriptor sets of a given layout. You provide a list of <a href="structtp_1_1_descriptor_set_setup.html" class="m-doc">tp::<wbr />DescriptorSetSetup</a> structs and a corresponding list of <a href="classtp_1_1_descriptor_set.html" class="m-doc">tp::<wbr />DescriptorSet</a> pointers, to which the created sets will be written.</p><p>A <a href="structtp_1_1_descriptor_set_setup.html" class="m-doc">tp::<wbr />DescriptorSetSetup</a> is simply a list of <a href="classtp_1_1_descriptor.html" class="m-doc">tp::<wbr />Descriptor</a> objects representing the resource views to bind, along with some optional flags and a debug name. The order of the descriptors must follow the order of bindings provided when the given descriptor set layout was created. The descriptors do not correspond 1:1 to bindings, but instead as many descriptors are needed as is the <code>arraySize</code> of the corresponding binding. These descriptors are then tightly packed in the list.</p><p>For example, if we have a <a href="classtp_1_1_descriptor_set_layout.html" class="m-doc">tp::<wbr />DescriptorSetLayout</a> created like so:</p><pre class="m-code"><span class="n">tp</span><span class="o">::</span><span class="n">DescriptorSetLayout</span><span class="w"> </span><span class="n">layout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="o">-&gt;</span><span class="n">createDescriptorSetLayout</span><span class="p">({</span><span class="w"></span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">DescriptorBinding</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">DescriptorType</span><span class="o">::</span><span class="n">UniformBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ShaderStage</span><span class="o">::</span><span class="n">Vertex</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">DescriptorBinding</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">DescriptorType</span><span class="o">::</span><span class="n">UniformBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ShaderStage</span><span class="o">::</span><span class="n">Fragment</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">DescriptorBinding</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">DescriptorType</span><span class="o">::</span><span class="n">Sampler</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ShaderStage</span><span class="o">::</span><span class="n">Fragment</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">DescriptorBinding</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">DescriptorType</span><span class="o">::</span><span class="n">SampledImage</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ShaderStage</span><span class="o">::</span><span class="n">Fragment</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">),</span><span class="w"></span>
<span class="p">});</span><span class="w"></span></pre><p>Then we can allocate a <a href="classtp_1_1_descriptor_set.html" class="m-doc">tp::<wbr />DescriptorSet</a> for it as such:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">tp</span><span class="o">::</span><span class="n">Descriptor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">descriptors</span><span class="p">;</span><span class="w"></span>
<span class="n">descriptors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vertexConstants</span><span class="p">);</span><span class="w"></span>
<span class="n">descriptors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">fragmentConstants</span><span class="p">);</span><span class="w"></span>
<span class="n">descriptors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">linearSampler</span><span class="p">);</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">descriptors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">textures</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">auto</span><span class="w"> </span><span class="n">descSetSetup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">DescriptorSetSetup</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">view</span><span class="p">(</span><span class="n">descriptors</span><span class="p">));</span><span class="w"></span>
<span class="n">tp</span><span class="o">::</span><span class="n">DescriptorSet</span><span class="w"> </span><span class="n">descriptorSet</span><span class="p">;</span><span class="w"></span>
<span class="n">descriptorPool</span><span class="o">-&gt;</span><span class="n">allocateDescriptorSets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">layout</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">descSetSetup</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">descriptorSet</span><span class="w"> </span><span class="p">});</span><span class="w"></span></pre><p>Descriptors cannot reference job-local resources before the job has been enqueued - this is because internally, the resources don&#x27;t actually exist until then. This is a fairly common use case, however. For that reason, you can also create job-local descriptor sets with <a href="classtp_1_1_job.html#ac6bb755680a758beacd00637176b8f9e" class="m-doc">tp::<wbr />Job::<wbr />allocateLocalDescriptorSet</a>. Just like job-local resources, their lifetime is limited to just the single job and are reused internally, so they are also ideal for sets that change from frame to frame. You can create them by filling up an array of <a href="classtp_1_1_future_descriptor.html" class="m-doc">tp::<wbr />FutureDescriptor</a> instead and only get a non-owning view of the descriptor set. All descriptor sets are used mainly through this <a href="classtp_1_1_descriptor_set_view.html" class="m-doc">tp::<wbr />DescriptorSetView</a>, accessible with <a href="classtp_1_1_descriptor_set.html#ac480e7fc0296e328b9e80cdcc2c28e11" class="m-doc">tp::<wbr />DescriptorSet::<wbr />getView</a>.</p><p>By default, all descriptors provided to <a href="structtp_1_1_descriptor_set_setup.html" class="m-doc">tp::<wbr />DescriptorSetSetup</a> must be valid. Sometimes we know that not all of the descriptors in a descriptor set will end up being used. Rather than having to create dummy resources, we can set the <a href="namespacetp.html#afeffbd775f102eab953d2e15c407f65ca50223315f8890cb78c5d55f8440250c1" class="m-doc">tp::<wbr />DescriptorSetFlag::<wbr />IgnoreNullDescriptors</a> flag, which will relax the above requirement and let us use empty descriptors when allocating descriptor sets. Note also that if a pipeline contains any access to the descriptor, even if it is behind a branch that won&#x27;t be taken, it is still considered to be (statically) using the descriptor, which means it must not be null. The <a href="namespacetp.html#a68db4f071c78c4f26776f577588416bba16d008687eb1211c484cfc25158d727d" class="m-doc">tp::<wbr />DescriptorBindingFlag::<wbr />PartiallyBound</a> flag relaxes that even further for particular bindings, forbidding null descriptors only where they will actually be accessed by the active code path (dynamically used).</p><div class="m-note m-dim"><p>If you&#x27;re familiar with Vulkan descriptor sets, you might notice that unlike those, Tephra&#x27;s descriptor sets are immutable. Mutating descriptor sets in Vulkan involves waiting until they are no longer in use by the device, something we generally want to avoid. The common solution then is to just allocate a new set now and recycle the old one later. Tephra just embraces this pattern. When mutability might be convenient, there is the <a href="classtp_1_1utils_1_1_mutable_descriptor_set.html" class="m-doc">tp::<wbr />utils::<wbr />MutableDescriptorSet</a> utility class, but even that just builds upon the basic immutable descriptor sets.</p><p>The descriptor set allocator separates the sets by their layout. This makes all the descriptor sets allocated from each pool have the same size and simplifies the allocation algorithm. Job resource pools internally have the same descriptor pool for serving job-local descriptor set allocations. Their allocation just gets deferred until the job is enqueued.</p></div><p><br /></p></section><section id="ug-descriptors-binding"><h3><a href="#ug-descriptors-binding">Binding descriptor sets</a></h3><p><a href="classtp_1_1_render_list.html" class="m-doc">tp::<wbr />RenderList</a> and <a href="classtp_1_1_compute_list.html" class="m-doc">tp::<wbr />ComputeList</a> keep the state of currently bound descriptor sets for each set number. Any time a draw or dispatch call is made with a compatible pipeline bound, it can access the resources referenced by the currently bound descriptor sets in the command list state. <a href="classtp_1_1_command_list.html#a0636227ef981fbd2998c802dd73a8eb2" class="m-doc">tp::<wbr />CommandList::<wbr />cmdBindDescriptorSets</a> is responsible for changing that state. It operates with a given <a href="classtp_1_1_pipeline_layout.html" class="m-doc">tp::<wbr />PipelineLayout</a>, a list of <a href="classtp_1_1_descriptor_set_view.html" class="m-doc">tp::<wbr />DescriptorSetView</a> objects to bind, the set number that the first set in the list should be bound to and optionally a list of dynamic offsets.</p><p>Dynamic offsets are used for <a href="namespacetp.html#a3dccbef68c07e939a1f37825018d2c67a517b91f0588b3bf6c80ff3b19b2a7f57" class="m-doc">tp::<wbr />DescriptorType::<wbr />UniformBufferDynamic</a> and <a href="namespacetp.html#a3dccbef68c07e939a1f37825018d2c67ada8c94227ee0e3b5cd40da12d594ad55" class="m-doc">tp::<wbr />DescriptorType::<wbr />StorageBufferDynamic</a> descriptors, which are useful when needing to pass different parts of the same buffer for use in shaders efficiently, without creating new descriptor sets each time. The most common example of that being uniform buffers for shader constants.</p><p>Calling <a href="classtp_1_1_command_list.html#a0636227ef981fbd2998c802dd73a8eb2" class="m-doc">tp::<wbr />CommandList::<wbr />cmdBindDescriptorSets</a> may sometimes unbind other previously bound descriptor sets depending on the pipeline layout used. If the new pipeline layout was created with a descriptor set layout that was defined differently from the one currently used for the same set number, then that descriptor set becomes unbound (and accesses made to its resources will be undefined). Additionally, all descriptor sets with a higher set number will get unbound, too. A good mental picture to explain this behavior is to imagine that there exists a flat buffer storing the currently bound resource descriptors. Pipeline layouts then keep offsets into this buffer for each of its descriptor set layouts. Upon calling <code><a href="classtp_1_1_command_list.html#a0636227ef981fbd2998c802dd73a8eb2" class="m-doc">tp::<wbr />CommandList::<wbr />cmdBindDescriptorSets</a></code>, the contents of the descriptor sets simply get copied according to the offset.</p><p>The consequence of this is that frequently changing descriptor set layouts should be assigned to a higher set number than ones that are shared among many pipeline layouts. For example, it makes sense to put all the &quot;global&quot; bindings that can be used by many different pipelines, such as shadow maps, to set number 0, while various material-dependent bindings ought to be in higher set numbers. That way, changing &quot;material&quot; descriptor set layout won&#x27;t disturb the &quot;global&quot; descriptor set layout.</p><p><br /></p><hr/></section></section><section id="ug-pipelines"><h2><a href="#ug-pipelines">Pipelines</a></h2><section id="ug-pipelines-shaders"><h3><a href="#ug-pipelines-shaders">Shaders</a></h3><p>Tephra, just like Vulkan, consumes shaders in SPIR-V. This language, rather than being human readable, serves as an easy-to-parse intermediate representation in a binary format. It is the user&#x27;s responsibility to compile shaders from other shader languages, like GLSL or HLSL, to SPIR-V using external tools. The Vulkan SDK contains Khronos <a href="https://github.com/KhronosGroup/glslang">glslangValidator</a> and Microsoft <a href="https://github.com/microsoft/DirectXShaderCompiler">DXC</a> binaries for compiling GLSL / HLSL to SPIR-V, respectively. If you are already familiar with these languages, note that their use for Vulkan carries some differences. Consult these pages for <a href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/khr/GL_KHR_vulkan_glsl.txt">GLSL</a> and <a href="https://github.com/Microsoft/DirectXShaderCompiler/blob/main/docs/SPIR-V.rst">HLSL</a> for details about how they translate to SPIR-V.</p><p><a href="classtp_1_1_shader_module.html" class="m-doc">tp::<wbr />ShaderModule</a> objects are then used to hold the SPIR-V shader binaries and pass them to other parts of the library. They can be created by calling <a href="classtp_1_1_device.html#ade1b332f6a449b7bb2b4317dadb32d67" class="m-doc">tp::<wbr />Device::<wbr />createShaderModule</a> with the SPIR-V binary data. This step is fairly cheap, no driver compilation happens at this stage.</p><p><br /></p></section><section id="ug-pipelines-compute"><h3><a href="#ug-pipelines-compute">Compute pipelines</a></h3><p>To compile a compute <a href="classtp_1_1_pipeline.html" class="m-doc">tp::<wbr />Pipeline</a>, the <a href="classtp_1_1_compute_pipeline_setup.html" class="m-doc">tp::<wbr />ComputePipelineSetup</a> object needs to be prepared. Pipeline setup objects behave somewhat differently than other setup structures. Only the mandatory or commonly defined parameters are passed in the constructor. Most of them, however, can be provided through setter methods. This can be used to easily define multiple similar pipeline setups - just copy the setup object and change what is required.</p><p>The constructor of <a href="classtp_1_1_compute_pipeline_setup.html" class="m-doc">tp::<wbr />ComputePipelineSetup</a> takes a pointer to a <a href="classtp_1_1_pipeline_layout.html" class="m-doc">tp::<wbr />PipelineLayout</a>, which we&#x27;ve shown how to create in the <a href="user-guide.html#ug-descriptors-layouts" class="m-doc">Descriptor set layouts</a> section. The next parameter is a <a href="structtp_1_1_shader_stage_setup.html" class="m-doc">tp::<wbr />ShaderStageSetup</a> describing the only stage in a compute pipeline. This is an ordinary struct that stores a pointer to a <a href="classtp_1_1_shader_module.html" class="m-doc">tp::<wbr />ShaderModule</a> object providing the shader bytecode, the name of the entry point function and optionally a list of <a href="structtp_1_1_specialization_constant.html" class="m-doc">tp::<wbr />SpecializationConstant</a> structs. Specialization constants can be used to modify the behavior of a shader just before pipeline compilation. The only property of compute pipeline setups that isn&#x27;t present in the constructor are the pipeline flags, for adjusting the behavior of the pipeline and its compilation.</p><p>To compile compute pipelines, call <a href="classtp_1_1_device.html#a4278774363f368844a23f8aa311275d8" class="m-doc">tp::<wbr />Device::<wbr />compileComputePipelines</a> with an input list of pipeline setups and an output list of <a href="classtp_1_1_pipeline.html" class="m-doc">tp::<wbr />Pipeline</a> handles. A pointer to a <a href="classtp_1_1_pipeline_cache.html" class="m-doc">tp::<wbr />PipelineCache</a> object can additionally be provided. <a href="classtp_1_1_pipeline_cache.html" class="m-doc">tp::<wbr />PipelineCache</a> serves as an opaque cache of compiled pipelines that the driver can use to speed up their compilation. The cache data can be saved to disk and loaded back during a later run. The data is specific to the device that was used to compile pipelines the first time, so the cache isn&#x27;t portable across devices or even driver versions. The pipeline cache is thread-safe in regards to being used for pipeline compilation from multiple threads simultaneously.</p><p>A compute pipeline can be bound to the current state of a compute list with <a href="classtp_1_1_compute_list.html#a0b377fe3da1edec80b9a0e81087b0e65" class="m-doc">tp::<wbr />ComputeList::<wbr />cmdBindComputePipeline</a>. Any further dispatch commands in that list, such as <a href="classtp_1_1_compute_list.html#a9516223319123c64e738b820f47a9480" class="m-doc">tp::<wbr />ComputeList::<wbr />cmdDispatch</a>, will use the given pipeline until another one gets bound.</p><p><br /></p></section><section id="ug-pipelines-graphics"><h3><a href="#ug-pipelines-graphics">Graphics pipelines</a></h3><p>Graphics <a href="classtp_1_1_pipeline.html" class="m-doc">tp::<wbr />Pipeline</a> compilation works the same way as compute pipelines, but with more complexity and state to set.</p><p>In the constructor, <a href="classtp_1_1_graphics_pipeline_setup.html" class="m-doc">tp::<wbr />GraphicsPipelineSetup</a> also accepts a pointer to a <a href="classtp_1_1_pipeline_layout.html" class="m-doc">tp::<wbr />PipelineLayout</a> object. The only required stage is the vertex shader stage. It, along with the often used fragment shader stage can also be provided in the constructor. Other stages can be set with <a href="classtp_1_1_graphics_pipeline_setup.html#a4782bfb1b6138851c79a496bf7a29a6c" class="m-doc">tp::<wbr />GraphicsPipelineSetup::<wbr />setGeometryStage</a> and <a href="classtp_1_1_graphics_pipeline_setup.html#a654667a9f12c8aa45317cbe31144f23a" class="m-doc">tp::<wbr />GraphicsPipelineSetup::<wbr />setTessellationStages</a>.</p><p>Graphics pipelines can only be bound and used within render passes that have attachment image formats matching those declared as part of the pipeline setup. You can do so with the <a href="classtp_1_1_graphics_pipeline_setup.html#ac07f3755a00e365f4fbb1d54938d5bf4" class="m-doc">tp::<wbr />GraphicsPipelineSetup::<wbr />setDepthStencilAttachment</a> for the depth image and <a href="classtp_1_1_graphics_pipeline_setup.html#ae59acede27d24e2e7eed0df7f23b6f01" class="m-doc">tp::<wbr />GraphicsPipelineSetup::<wbr />setColorAttachments</a> for the color images. Both their number and format has to be the same as those of the image views that will be used for attachments in the render pass. This, along with other non-dynamic state of the graphics pipeline, means that you will likely end up with more than one pipeline for each shader stage combination.</p><p>Another commonly changed state is an array of <a href="structtp_1_1_vertex_input_binding.html" class="m-doc">tp::<wbr />VertexInputBinding</a> describing the input interface of the vertex processing. One binding in the array corresponds to one vertex buffer bound at the same index. The structure contains a list of <a href="structtp_1_1_vertex_input_attribute.html" class="m-doc">tp::<wbr />VertexInputAttribute</a> structs describing the layout of the attributes within this buffer and how they map to the attribute indices used in the shader. <a href="structtp_1_1_vertex_input_binding.html" class="m-doc">tp::<wbr />VertexInputBinding</a> also specifies whether the binding is to be consumed per-vertex, or per-instance. They can be set trough <a href="classtp_1_1_graphics_pipeline_setup.html#abd687658ab5b2654b9bea04a1ccc7a03" class="m-doc">tp::<wbr />GraphicsPipelineSetup::<wbr />setVertexInputBindings</a>. The topology of the input primitives, by default set to <a href="namespacetp.html#a12b2dbc0529baf76533e072273ffaf14af5beeab7a1f452e5b0e9b03b44f0de92" class="m-doc">tp::<wbr />PrimitiveTopology::<wbr />TriangleList</a>, can be changed with <a href="classtp_1_1_graphics_pipeline_setup.html#a40fefc82949cd0f91d5009247116103e" class="m-doc">tp::<wbr />GraphicsPipelineSetup::<wbr />setTopology</a>.</p><p>There are many other configurable states affecting all parts of the graphics pipeline. One of the more important ones is <a href="classtp_1_1_graphics_pipeline_setup.html#ab4905f4d7d3cccf99410f216157aade7" class="m-doc">tp::<wbr />GraphicsPipelineSetup::<wbr />setDepthTest</a>. By default, all depth operations are disabled. Setting <code>enable</code> to true enables depth operations with the given depth test comparison operator. <code>enableWrite</code> also optionally enables depth writes. If depth (or stencil) operations are enabled, the pipeline setup must also describe a valid depth attachment.</p><p>By default, face culling is also disabled. That can be changed by calling <a href="classtp_1_1_graphics_pipeline_setup.html#af84dabc2c2f86fb52a6c3f99e62e7813" class="m-doc">tp::<wbr />GraphicsPipelineSetup::<wbr />setCullMode</a>, while also allowing you to specify which faces should be considered as front facing with <a href="classtp_1_1_graphics_pipeline_setup.html#a9920804dd48e6126ce84995f1d5be2e2" class="m-doc">tp::<wbr />GraphicsPipelineSetup::<wbr />setFrontFace</a>.</p><p>Attachment blending also needs to be explicitly enabled with either <a href="classtp_1_1_graphics_pipeline_setup.html#a38b8387d74315e60f494396e171eea11" class="m-doc">tp::<wbr />GraphicsPipelineSetup::<wbr />setBlending</a> or, if different blending modes for each of the color attachments are desired, <a href="classtp_1_1_graphics_pipeline_setup.html#a7c55e66bd6900f841d222dbce495298a" class="m-doc">tp::<wbr />GraphicsPipelineSetup::<wbr />setIndependentBlending</a>. Either of them take the <a href="structtp_1_1_attachment_blend_state.html" class="m-doc">tp::<wbr />AttachmentBlendState</a> structure, which describes the <a href="structtp_1_1_blend_state.html" class="m-doc">tp::<wbr />BlendState</a> for the color and alpha components, as well as a mask disabling/enabling the individual components. <a href="structtp_1_1_blend_state.html" class="m-doc">tp::<wbr />BlendState</a> is defined as a pair of <a href="namespacetp.html#a61ff7a7fc09d75005d831407a545073c" class="m-doc">tp::<wbr />BlendFactor</a> settings, the first applied to the source value and the other to the destination value and a <a href="namespacetp.html#a1adc8c964207f52d3ec83dc7d4d29a7e" class="m-doc">tp::<wbr />BlendOp</a> that determines how they will be combined.</p><p>Some state can also be declared as dynamic through <a href="classtp_1_1_graphics_pipeline_setup.html#a4df4a4bf5eb1657eebf99af79d4608fc" class="m-doc">tp::<wbr />GraphicsPipelineSetup::<wbr />addDynamicState</a>. Dynamic state will ignore whatever values are defined for it in the pipeline setup and must instead be set at runtime with the various state setter methods in <a href="classtp_1_1_render_list.html" class="m-doc">tp::<wbr />RenderList</a>. This may help reduce the number of pipelines needing to be compiled.</p><pre class="m-code"><span class="c1">// Read compiled SPIR-V shaders from disk</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vertexShaderCode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">loadShader</span><span class="p">(</span><span class="s">&quot;vsExample.spv&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fragmentShaderCode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">loadShader</span><span class="p">(</span><span class="s">&quot;fsExample.spv&quot;</span><span class="p">);</span><span class="w"></span>

<span class="n">tp</span><span class="o">::</span><span class="n">ShaderModule</span><span class="w"> </span><span class="n">vertexShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="o">-&gt;</span><span class="n">createShaderModule</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">view</span><span class="p">(</span><span class="n">vertexShaderCode</span><span class="p">));</span><span class="w"></span>
<span class="n">tp</span><span class="o">::</span><span class="n">ShaderModule</span><span class="w"> </span><span class="n">fragmentShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="o">-&gt;</span><span class="n">createShaderModule</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">view</span><span class="p">(</span><span class="n">fragmentShaderCode</span><span class="p">));</span><span class="w"></span>

<span class="k">auto</span><span class="w"> </span><span class="n">vertexShaderSetup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ShaderStageSetup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertexShader</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;main&quot;</span><span class="p">);</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">fragmentShaderSetup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ShaderStageSetup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fragmentShader</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;main&quot;</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Use an already prepared pipeline layout</span>
<span class="k">auto</span><span class="w"> </span><span class="n">pipelineSetup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">GraphicsPipelineSetup</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">pipelineLayout</span><span class="p">,</span><span class="w"> </span><span class="n">vertexShaderSetup</span><span class="p">,</span><span class="w"> </span><span class="n">fragmentShaderSetup</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Set the formats of the attachments that will be used</span>
<span class="n">pipelineSetup</span><span class="p">.</span><span class="n">setDepthStencilAttachment</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">Format</span><span class="o">::</span><span class="n">DEPTH32_D32_SFLOAT</span><span class="p">);</span><span class="w"></span>
<span class="n">pipelineSetup</span><span class="p">.</span><span class="n">setColorAttachments</span><span class="p">({</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">Format</span><span class="o">::</span><span class="n">COL32_B8G8R8A8_UNORM</span><span class="w"> </span><span class="p">});</span><span class="w"></span>

<span class="c1">// Back face culling</span>
<span class="n">pipelineSetup</span><span class="p">.</span><span class="n">setCullMode</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">CullModeFlag</span><span class="o">::</span><span class="n">BackFace</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Depth test without writing</span>
<span class="n">pipelineSetup</span><span class="p">.</span><span class="n">setDepthTest</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">CompareOp</span><span class="o">::</span><span class="n">LessOrEqual</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Use alpha blending, disable writing to the alpha channel</span>
<span class="k">auto</span><span class="w"> </span><span class="n">alphaBlendState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">AttachmentBlendState</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">BlendState</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">BlendFactor</span><span class="o">::</span><span class="n">SrcAlpha</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">BlendFactor</span><span class="o">::</span><span class="n">OneMinusSrcAlpha</span><span class="p">),</span><span class="w"> </span><span class="c1">// colorBlend</span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">BlendState</span><span class="o">::</span><span class="n">NoBlend</span><span class="p">(),</span><span class="w"> </span><span class="c1">// alphaBlend</span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">ColorComponent</span><span class="o">::</span><span class="n">Red</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ColorComponent</span><span class="o">::</span><span class="n">Green</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ColorComponent</span><span class="o">::</span><span class="n">Blue</span><span class="w"> </span><span class="c1">// writeMask</span>
<span class="p">);</span><span class="w"></span>
<span class="n">pipelineSetup</span><span class="p">.</span><span class="n">setBlending</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">alphaBlendState</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Also create a version with multisampling</span>
<span class="n">tp</span><span class="o">::</span><span class="n">GraphicsPipelineSetup</span><span class="w"> </span><span class="n">msPipelineSetup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pipelineSetup</span><span class="p">;</span><span class="w"></span>
<span class="n">msPipelineSetup</span><span class="p">.</span><span class="n">setMultisampling</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">MultisampleLevel</span><span class="o">::</span><span class="n">x4</span><span class="p">);</span><span class="w"></span>

<span class="n">device</span><span class="o">-&gt;</span><span class="n">compileGraphicsPipelines</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pipelineSetup</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">msPipelineSetup</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pipeline</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">msPipeline</span><span class="w"> </span><span class="p">});</span><span class="w"></span></pre><p><br /></p><hr/></section></section><section id="ug-swapchain"><h2><a href="#ug-swapchain">Swapchain</a></h2><p>To actually display the contents of an image to the screen requires the use of a <a href="classtp_1_1_swapchain.html" class="m-doc">tp::<wbr />Swapchain</a>. This is an optional feature - Tephra will work in a headless scenario and may even be run on a graphics device that does not support any display output. The support should be checked and enabled on an application level with the <a href="namespacetp_1_1_application_extension.html#aed1bc7ad1ffce334894bb898667dc3ec" class="m-doc">tp::<wbr />ApplicationExtension::<wbr />KHR_Surface</a> application extension, and on device level with the <a href="namespacetp_1_1_device_extension.html#adc15a5a63bec60fa63cc6ea59d1ea392" class="m-doc">tp::<wbr />DeviceExtension::<wbr />KHR_Swapchain</a> device extension.</p><p>To create a <a href="classtp_1_1_swapchain.html" class="m-doc">tp::<wbr />Swapchain</a> for a device that has the needed extensions enabled, call <a href="classtp_1_1_device.html#ace820228473cae7aa2a9cf30d978483a" class="m-doc">tp::<wbr />Device::<wbr />createSwapchainKHR</a>. The method accepts a <a href="structtp_1_1_swapchain_setup.html" class="m-doc">tp::<wbr />SwapchainSetup</a> setup structure that holds most of the required parameters, as well as an optional pointer to an old <a href="classtp_1_1_swapchain.html" class="m-doc">tp::<wbr />Swapchain</a> object. If given, the implementation will be able to reuse resources from it, transitioning it to a <a href="namespacetp.html#a4a14ed8aa064f1af362ae2ee1e87ace1ad109ac74df282488efd1dd7621a847d2" class="m-doc">tp::<wbr />SwapchainStatus::<wbr />Retired</a> state. More on those later.</p><p>The first parameter of the <a href="structtp_1_1_swapchain_setup.html" class="m-doc">tp::<wbr />SwapchainSetup</a> structure is the Vulkan   <a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html" class="m-doc-external">VkSurfaceKHR</a> handle, representing a window, display or other surface that the swapchain can present onto. This handle needs to be acquired through platform-specific ways and is out of scope of this library. Other libraries, like <a href="https://www.glfw.org/docs/3.3/vulkan_guide.html">GLFW</a> can assist with creating a surface handle in a platform-independent way.</p><p>Before a   <a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html" class="m-doc-external">VkSurfaceKHR</a> handle can be used, you should check whether your device supports presenting to that particular surface. This can be done with <a href="classtp_1_1_physical_device.html#a47e886aaff9e5bf92e96899dfb64060f" class="m-doc">tp::<wbr />PhysicalDevice::<wbr />querySurfaceCapabilitiesKHR</a>. The method returns a <a href="structtp_1_1_surface_capabilities.html" class="m-doc">tp::<wbr />SurfaceCapabilities</a> structure for that particular surface-device combination. <a href="structtp_1_1_surface_capabilities.html#aa6ec0b95e611783f69bf97e83c4c9adb" class="m-doc">tp::<wbr />SurfaceCapabilities::<wbr />isSupported</a> can be called if the surface can be presented to at all. The rest of the capability values in the structure should be used to help fill out the remaining parameters in the <a href="structtp_1_1_swapchain_setup.html" class="m-doc">tp::<wbr />SwapchainSetup</a> setup structure.</p><p>Its second parameter, the <a href="namespacetp.html#ad7c69a8d8b81187a779224a594b4ed27" class="m-doc">tp::<wbr />PresentMode</a> enum, chooses how presenting consecutive frames will be handled, and together with the next parameter <code>minImageCount</code> allows making trade-offs between display latency, tearing and stability. The <code>imageUsage</code>, <code>imageFormat</code>, <code>imageExtent</code> and <code>imageArrayLayerCount</code> work similarly to the equivalent parameters of <a href="structtp_1_1_image_setup.html" class="m-doc">tp::<wbr />ImageSetup</a>, except that they are limited by the capabilities of both the surface and the device. They apply to images that the swapchain creates for the purposes of presentation. <code>imageCompatibleFormatsKHR</code> also allows specifying additional formats that views of those images can take, however the use of this parameter additionally requires the <a href="namespacetp_1_1_device_extension.html#aadba691ebfaae8d05299093553ea8ffc" class="m-doc">tp::<wbr />DeviceExtension::<wbr />KHR_SwapchainMutableFormat</a> extension to be enabled. There are other optional parameters that can further modify various aspects of presentation and composition. See the <a href="structtp_1_1_swapchain_setup.html" class="m-doc">tp::<wbr />SwapchainSetup</a> documentation for details.</p><pre class="m-code"><span class="c1">// Manages drawing to a window using the Tephra swapchain</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Window</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">Window</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">Device</span><span class="o">*</span><span class="w"> </span><span class="n">physicalDevice</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">Device</span><span class="o">*</span><span class="w"> </span><span class="n">device</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">physicalDevice</span><span class="p">(</span><span class="n">physicalDevice</span><span class="p">),</span><span class="w"> </span><span class="n">device</span><span class="p">(</span><span class="n">device</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// VkSurfaceKHR gets created here in some platform-dependent way, or with a library</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">recreateSwapchain</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">capabilities</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physicalDevice</span><span class="o">-&gt;</span><span class="n">querySurfaceCapabilitiesKHR</span><span class="p">(</span><span class="n">surface</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Prefer the extent specified by the surface over what&#39;s provided</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">capabilities</span><span class="p">.</span><span class="n">currentExtent</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">~</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">capabilities</span><span class="p">.</span><span class="n">currentExtent</span><span class="p">.</span><span class="n">width</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">capabilities</span><span class="p">.</span><span class="n">currentExtent</span><span class="p">.</span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Prefer triple buffering</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">minImageCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">capabilities</span><span class="p">.</span><span class="n">maxImageCount</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">capabilities</span><span class="p">.</span><span class="n">maxImageCount</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">minImageCount</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">minImageCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">capabilities</span><span class="p">.</span><span class="n">maxImageCount</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Prefer RelaxedFIFO if available, otherwise fallback to FIFO, which is always supported</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">presentMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">PresentMode</span><span class="o">::</span><span class="n">FIFO</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">PresentMode</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">capabilities</span><span class="p">.</span><span class="n">supportedPresentModes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">PresentMode</span><span class="o">::</span><span class="n">RelaxedFIFO</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">presentMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">PresentMode</span><span class="o">::</span><span class="n">RelaxedFIFO</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Check if the swapchain supports the required format</span>
<span class="w">        </span><span class="k">constexpr</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">Format</span><span class="w"> </span><span class="n">imageFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">Format</span><span class="o">::</span><span class="n">COL32_B8G8R8A8_UNORM</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">supportsRequiredFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">Format</span><span class="w"> </span><span class="n">format</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">capabilities</span><span class="p">.</span><span class="n">supportedFormatsSRGB</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">format</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">imageFormat</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="n">supportsRequiredFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">supportsRequiredFormat</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">swapchainSetup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">SwapchainSetup</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">surface</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">presentMode</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">minImageCount</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">tp</span><span class="o">::</span><span class="n">ImageUsage</span><span class="o">::</span><span class="n">ColorAttachment</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">imageFormat</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="p">});</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Reuse old swapchain, if available</span>
<span class="w">        </span><span class="n">swapchain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="o">-&gt;</span><span class="n">createSwapchainKHR</span><span class="p">(</span><span class="n">swapchainSetup</span><span class="p">,</span><span class="w"> </span><span class="n">swapchain</span><span class="p">.</span><span class="n">get</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">PhysicalDevice</span><span class="o">*</span><span class="w"> </span><span class="n">physicalDevice</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">Device</span><span class="o">*</span><span class="w"> </span><span class="n">device</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">VkSurfaceKHR</span><span class="w"> </span><span class="n">surface</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">tp</span><span class="o">::</span><span class="n">Swapchain</span><span class="o">&gt;</span><span class="w"> </span><span class="n">swapchain</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// List of past frame&#39;s semaphores that we will use to limit framerate</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">tp</span><span class="o">::</span><span class="n">JobSemaphore</span><span class="o">&gt;</span><span class="w"> </span><span class="n">frameSemaphores</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span></pre><p>Once created, the swapchain will be in the <a href="namespacetp.html#a4a14ed8aa064f1af362ae2ee1e87ace1acb61fef1e5e79e07a80421cb9a073a80" class="m-doc">tp::<wbr />SwapchainStatus::<wbr />Optimal</a> status. You can check this by calling the <a href="classtp_1_1_swapchain.html#a0f004a5ef0b2692bc00e56215d0d00f6" class="m-doc">tp::<wbr />Swapchain::<wbr />getStatus()</a> method. The optimal status means the swapchain is ready for presentation and also matches the surface properties. The status can change during swapchain operations, so it is recommended to check periodically.<br /><a href="namespacetp.html#a4a14ed8aa064f1af362ae2ee1e87ace1ac2ef5a5e62bb51ac4155f5a0bd952baa" class="m-doc">tp::<wbr />SwapchainStatus::<wbr />Suboptimal</a> means the swapchain can still be used, but it may not match surface properties anymore and you should consider recreating it when convenient. <a href="namespacetp.html#a4a14ed8aa064f1af362ae2ee1e87ace1a71a527df74712769b7e748407cb281b5" class="m-doc">tp::<wbr />SwapchainStatus::<wbr />OutOfDate</a>, on the other hand, means that the swapchain is no longer compatible and any further operations on it will fail. <a href="namespacetp.html#a4a14ed8aa064f1af362ae2ee1e87ace1aa7f68a45c72714e84821d68f2164720f" class="m-doc">tp::<wbr />SwapchainStatus::<wbr />SurfaceLost</a> is even worse, making you create a new   <a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html" class="m-doc-external">VkSurfaceKHR</a>, too. When something causes the swapchain to go out of date or lose its surface inside a swapchain operation, a <a href="classtp_1_1_out_of_date_error.html" class="m-doc">tp::<wbr />OutOfDateError</a> and <a href="classtp_1_1_surface_lost_error.html" class="m-doc">tp::<wbr />SurfaceLostError</a> errors also get raised, respectively. Most <code>Suboptimal</code> and <code>OutOfDate</code> status changes happen due to the underlying window being resized. It might be more convenient to handle resize events of your windowing system pre-emptively, so that these errors never happen.</p><p>To receive an image to draw onto and later present, call <a href="classtp_1_1_swapchain.html#af5f7f82ffb047af7b3e388ee894a0500" class="m-doc">tp::<wbr />Swapchain::<wbr />acquireNextImage</a> with an optional timeout value. As a result, if successful, it returns tp::AcquireImageInfo structure consisting of the image itself, the index of the image in the swapchain&#x27;s internal array and an acquire and present semaphores. The swapchain operations must be synchronized with rendering using those semaphores. The first <a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a> that will access the newly acquired image must wait on the acquire semaphore (<code>waitExternalSemaphores</code> parameter of <a href="classtp_1_1_device.html#a1fb94f90c9cd0968b70750ec5be5a41b" class="m-doc">tp::<wbr />Device::<wbr />enqueueJob</a>) to make sure the image is ready.</p><p>The last job writing to the image before the present operation must export it with <a href="classtp_1_1_job.html#a967f5a891d8e50cb73d0f6b7c6cec066" class="m-doc">tp::<wbr />Job::<wbr />cmdExportResource</a> using the <a href="namespacetp.html#a2a231ee79583b288a3be330f401bf174ae53d1b98a6b6b169a92a8cac08ac0534" class="m-doc">tp::<wbr />ReadAccess::<wbr />ImagePresentKHR</a> read access and also include the present semaphore in its <code>signalExternalSemaphores</code> parameter upon enqueue. Only once all jobs are enqueued and submitted in the correct order, you can finally call tp::Device::submitPresent, specifying a <a href="structtp_1_1_device_queue.html" class="m-doc">tp::<wbr />DeviceQueue</a>, the swapchain itself and the index of the image previously acquired. The queue type must be one of the supported ones in <a href="structtp_1_1_surface_capabilities.html" class="m-doc">tp::<wbr />SurfaceCapabilities</a>, which the graphics queue type almost always is. Once an image has been submitted for presentation, it must not be accessed until it gets acquired again.</p><p>Conceptually, <a href="classtp_1_1_swapchain.html" class="m-doc">tp::<wbr />Swapchain</a> maintains a list of images created specifically for displaying them on the given surface. The acquire operation either grabs one of those images, if possible, or blocks until one is available. The user then can write data to it data through the rest of the API just like it is an ordinary image. A later tp::Device::submitPresent operation then queues the image to be displayed onto the screen, making it unable to be acquired until the presentation engine is done with it. Older APIs like OpenGL have both of these operations merged in a single glutSwapBuffers call.</p><pre class="m-code"><span class="kt">bool</span><span class="w"> </span><span class="nf">Window::drawFrame</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Limit the number of outstanding frames being rendered - this is better than relying on</span>
<span class="w">    </span><span class="c1">// acquire to block for us</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">frameSemaphores</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">device</span><span class="o">-&gt;</span><span class="n">waitForJobSemaphores</span><span class="p">({</span><span class="w"> </span><span class="n">frameSemaphores</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="w">        </span><span class="n">frameSemaphores</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">swapchain</span><span class="o">-&gt;</span><span class="n">getStatus</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">SwapchainStatus</span><span class="o">::</span><span class="n">Optimal</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Recreate out of date or suboptimal swapchain</span>
<span class="w">        </span><span class="n">recreateSwapchain</span><span class="p">(</span><span class="n">getWindowWidth</span><span class="p">(),</span><span class="w"> </span><span class="n">getWindowHeight</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Acquire a swapchain image to draw the frame to</span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">AcquiredImageInfo</span><span class="w"> </span><span class="n">acquiredImage</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">acquiredImage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swapchain</span><span class="o">-&gt;</span><span class="n">acquireNextImage</span><span class="p">().</span><span class="n">value</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">OutOfDateError</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Try next frame</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">SurfaceLostError</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Recreate surface in a platform-dependent way and try next frame</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create a simple example job to draw the frame</span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">Job</span><span class="w"> </span><span class="n">renderJob</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jobResourcePool</span><span class="o">-&gt;</span><span class="n">createJob</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// We don&#39;t need the swapchain image&#39;s old contents. It&#39;s good practice to discard.</span>
<span class="w">    </span><span class="n">renderJob</span><span class="p">.</span><span class="n">cmdDiscardContents</span><span class="p">(</span><span class="o">*</span><span class="n">acquiredImage</span><span class="p">.</span><span class="n">image</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// The render code should go here. For this example, just clear to magenta.</span>
<span class="w">    </span><span class="n">renderJob</span><span class="p">.</span><span class="n">cmdClearImage</span><span class="p">(</span><span class="o">*</span><span class="n">acquiredImage</span><span class="p">.</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ClearValue</span><span class="o">::</span><span class="n">ColorFloat</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Finally export for present</span>
<span class="w">    </span><span class="n">renderJob</span><span class="p">.</span><span class="n">cmdExportResource</span><span class="p">(</span><span class="o">*</span><span class="n">acquiredImage</span><span class="p">.</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">ReadAccess</span><span class="o">::</span><span class="n">ImagePresentKHR</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Enqueue and submit the job, synchronizing it with the presentation engine&#39;s semaphores</span>
<span class="w">    </span><span class="n">tp</span><span class="o">::</span><span class="n">JobSemaphore</span><span class="w"> </span><span class="n">jobSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="o">-&gt;</span><span class="n">enqueueJob</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">tp</span><span class="o">::</span><span class="n">QueueType</span><span class="o">::</span><span class="n">Graphics</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">renderJob</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">{},</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="n">acquiredImage</span><span class="p">.</span><span class="n">acquireSemaphore</span><span class="w"> </span><span class="p">},</span><span class="w">  </span><span class="c1">// the wait semaphore</span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="n">acquiredImage</span><span class="p">.</span><span class="n">presentSemaphore</span><span class="w"> </span><span class="p">});</span><span class="w"> </span><span class="c1">// the signal semaphore</span>

<span class="w">    </span><span class="n">device</span><span class="o">-&gt;</span><span class="n">submitQueuedJobs</span><span class="p">(</span><span class="n">tp</span><span class="o">::</span><span class="n">QueueType</span><span class="o">::</span><span class="n">Graphics</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Keep the job&#39;s semaphore so we can wait on it later.</span>
<span class="w">    </span><span class="n">frameSemaphores</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">jobSemaphore</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Present the image</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">device</span><span class="o">-&gt;</span><span class="n">submitPresentImagesKHR</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">tp</span><span class="o">::</span><span class="n">QueueType</span><span class="o">::</span><span class="n">Graphics</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="n">swapchain</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="n">acquiredImage</span><span class="p">.</span><span class="n">imageIndex</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">tp</span><span class="o">::</span><span class="n">OutOfDateError</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Let the swapchain be recreated next frame</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p><br /></p><hr/></section><section id="ug-utilities"><h2><a href="#ug-utilities">Utilities</a></h2><p>Tephra also provides some additional utilities built on top of the base API. They live in the <a href="namespacetp_1_1utils.html" class="m-doc">tp::<wbr />utils</a> namespace and must be included separately. They can be either used directly, or as examples of what can be build on top of the API.</p><p><br /></p><section id="ug-utilities-standard-report-handler"><h3><a href="#ug-utilities-standard-report-handler">Standard report handler</a></h3><p>The <a href="classtp_1_1utils_1_1_standard_report_handler.html" class="m-doc">tp::<wbr />utils::<wbr />StandardReportHandler</a> is an implementation of <a href="classtp_1_1_debug_report_handler.html" class="m-doc">tp::<wbr />DebugReportHandler</a> meant to simplify the process of reporting messages coming from Tephra and Vulkan. It can be used in two ways. The most straight forward is to instantiate it as-is, passing a <code>std::ostream</code> that messages will be directed to, and optionally specifying the message severity and types to report. The last parameter can additionally cause the handler to try and trigger a breakpoint of any attached debugger when an error occurs.</p><p>The second way is to make your own implementation of <a href="classtp_1_1_debug_report_handler.html" class="m-doc">tp::<wbr />DebugReportHandler</a>, but use the various static methods of the helper class for convenience. It provides the <a href="classtp_1_1utils_1_1_standard_report_handler.html#a1eae13c02887cf12e0d38f3002ca39c7" class="m-doc">tp::<wbr />utils::<wbr />StandardReportHandler::<wbr />formatDebugMessage</a> method, returning a formatted string compiling all the relevant message information. Similarly, <a href="classtp_1_1utils_1_1_standard_report_handler.html#aa4eb22a9f045753f97b86ff5095f1205" class="m-doc">tp::<wbr />utils::<wbr />StandardReportHandler::<wbr />formatRuntimeError</a> formats information about errors. The breakpoint trigger is also exposed as <a href="classtp_1_1utils_1_1_standard_report_handler.html#a82e4e8695b614b3a0043bbdb42bab526" class="m-doc">tp::<wbr />utils::<wbr />StandardReportHandler::<wbr />triggerDebugTrap</a>, powered by <a href="https://github.com/nemequ/portable-snippets">Evan Nemerson&#x27;s snippet</a>.</p><p><br /></p></section><section id="ug-utilities-growable-ring-buffer"><h3><a href="#ug-utilities-growable-ring-buffer">Growable ring buffer</a></h3><p>Tephra performs various allocation strategies when requesting pre-initialized buffers to offer a low memory usage and high performance when allocating temporary buffers for transferring data from the host to the device. Some of those strategies may be useful even outside of what <a href="classtp_1_1_job.html" class="m-doc">tp::<wbr />Job</a> allows. For example, periodically reading back data from the device also requires buffering, but pre-initialized buffers cannot be accessed after job submit, so they are not an option. The usual solution is to implement a ring buffer out of a regular buffer and checking when its data can be read and reused. This is similar to what Tephra does internally, so it is useful to expose it in a standard, more capable form.</p><p>As the name suggests, this implementation of ring buffers is resizable. A <a href="classtp_1_1utils_1_1_growable_ring_buffer.html" class="m-doc">tp::<wbr />utils::<wbr />GrowableRingBuffer</a> starts at zero size when created. It first needs to be fed with at least one backing buffer with <a href="classtp_1_1utils_1_1_growable_ring_buffer.html#a6f524fa7cbb3af0b99691a7b0c3a770b" class="m-doc">tp::<wbr />utils::<wbr />GrowableRingBuffer::<wbr />grow</a> that can be used to serve further allocation requests. Calling <a href="classtp_1_1utils_1_1_growable_ring_buffer.html#ad67cfd44ad47df4810e3b2f497d3dbf9" class="m-doc">tp::<wbr />utils::<wbr />GrowableRingBuffer::<wbr />push</a> with a given size will then try to allocate a buffer view of that size from the set of backing buffers. <a href="classtp_1_1utils_1_1_growable_ring_buffer.html#ae830f50b706a94fd1e00228e7da2c643" class="m-doc">tp::<wbr />utils::<wbr />GrowableRingBuffer::<wbr />pop</a>, on the other hand, will free the least recently allocated view, so that its space in one of the backing buffers can be reused. Similarly, <a href="classtp_1_1utils_1_1_growable_ring_buffer.html#a411957f425ba8d54cd9d4ff84933731b" class="m-doc">tp::<wbr />utils::<wbr />GrowableRingBuffer::<wbr />shrink</a> will attempt to release a backing buffer, if no allocations are using it at the moment.</p><p>The above can still require a considerable amount of management to create the backing buffers and ensure no allocations get popped prematurely. There is also a more user-friendly wrapper around this class, <a href="classtp_1_1utils_1_1_auto_ring_buffer.html" class="m-doc">tp::<wbr />utils::<wbr />AutoRingBuffer</a>, which manages the creation of backing buffers automatically. In its constructor, you provide a <a href="classtp_1_1_device.html" class="m-doc">tp::<wbr />Device</a> and all the parameters it needs to create and destroy its backing buffers. It also helps with correct popping of allocations. In <a href="classtp_1_1utils_1_1_auto_ring_buffer.html#afa46a07972a83e157a8b726d7ee6099d" class="m-doc">tp::<wbr />utils::<wbr />AutoRingBuffer::<wbr />push</a>, you also provide an arbitrary monotonically increasing &quot;timestamp&quot; value that gets assigned to the allocation. The <a href="classtp_1_1utils_1_1_auto_ring_buffer.html#a23a01c286ef05db9edc6f42336b9aaa9" class="m-doc">tp::<wbr />utils::<wbr />AutoRingBuffer::<wbr />pop</a> method then accepts another timestamp value, freeing all allocations with a value less or equal than that. The timestamp may be literally <a href="structtp_1_1_job_semaphore.html#a65bda016cf04a51eb62bb8cfad378903" class="m-doc">tp::<wbr />JobSemaphore::<wbr />timestamp</a> or any other useful value.</p><p>Another use of the ring buffers can be for job-local data of a size that you don&#x27;t know when the job is being recorded. It may be more convenient to write down shader constants at the same time as recording the actual draw calls to command lists. In that case a ring buffer may be used to allocate the constant data separately from a job, with a little bit of extra management. Similarly, you may have data that changes somewhat frequently, but can be used in the span of multiple jobs. A ring buffer may be useful there as well.</p><p><br /></p></section><section id="ug-utilities-mutable-descriptor-set"><h3><a href="#ug-utilities-mutable-descriptor-set">Mutable descriptor set</a></h3><p>Tephra&#x27;s descriptor sets are immutable and best suited for small sets of material-specific resources that are easily reusable. You may, however, want to additionally keep a set of &quot;global&quot; resources which can get bound and unbound at any time in a stateful fashion. <a href="classtp_1_1utils_1_1_mutable_descriptor_set.html" class="m-doc">tp::<wbr />utils::<wbr />MutableDescriptorSet</a> offers exactly that. You create it for a specific <a href="classtp_1_1_descriptor_set_layout.html" class="m-doc">tp::<wbr />DescriptorSetLayout</a>, just like a regular <a href="classtp_1_1_descriptor_set.html" class="m-doc">tp::<wbr />DescriptorSet</a>. <a href="classtp_1_1utils_1_1_mutable_descriptor_set.html#a235004cc78f5f47105199391bd4b3170" class="m-doc">tp::<wbr />utils::<wbr />MutableDescriptorSet::<wbr />set</a> then assigns a given <a href="classtp_1_1_descriptor.html" class="m-doc">tp::<wbr />Descriptor</a> to a descriptor index, but the changes don&#x27;t actually take effect until <a href="classtp_1_1utils_1_1_mutable_descriptor_set.html#a04af9043d97dcf3c2e0e3d4997e691ed" class="m-doc">tp::<wbr />utils::<wbr />MutableDescriptorSet::<wbr />commit</a> gets called. At that point a <a href="classtp_1_1_descriptor_set.html" class="m-doc">tp::<wbr />DescriptorSet</a> gets allocated using the state that has been set so far and the function returns a <a href="classtp_1_1_descriptor_set_view.html" class="m-doc">tp::<wbr />DescriptorSetView</a> that can be bound. At the end of the recording, <a href="classtp_1_1utils_1_1_mutable_descriptor_set.html#a842154c37077515994333e16dcd9b6a2" class="m-doc">tp::<wbr />utils::<wbr />MutableDescriptorSet::<wbr />releaseAndReset</a> should be called to let the set release its resources.</p><p>Note also that any descriptors that weren&#x27;t set by the time <a href="classtp_1_1utils_1_1_mutable_descriptor_set.html#a04af9043d97dcf3c2e0e3d4997e691ed" class="m-doc">tp::<wbr />utils::<wbr />MutableDescriptorSet::<wbr />commit</a> gets called are considered to be null descriptors and the same restrictions apply to them as mentioned in the <a href="user-guide.html#ug-descriptors-sets" class="m-doc">Descriptor sets</a> section, potentially also requiring the <a href="namespacetp.html#a68db4f071c78c4f26776f577588416bba16d008687eb1211c484cfc25158d727d" class="m-doc">tp::<wbr />DescriptorBindingFlag::<wbr />PartiallyBound</a> flag.</p><p>The mutable descriptor set can also be used to facilitate &quot;bindless&quot; setups, where all the resources used by all shaders in a frame get bound to the same descriptor set into large array bindings. In such cases it may be preferrable to update parts of the existing descriptor set, rather than allocating a fresh one, through the <a href="classtp_1_1utils_1_1_mutable_descriptor_set.html#aedbc219709beef89faafff3a5f8daea6" class="m-doc">tp::<wbr />utils::<wbr />MutableDescriptorSet::<wbr />setImmediate</a> function. Note, however, that there are some restrictions and features that need to be enabled to be able to update a descriptor set that has already been bound and is in use.</p></section></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script>
<script src="searchdata-v2.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Tephra Documentation. Created with <a href="https://doxygen.org/">Doxygen</a> 1.9.6 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
